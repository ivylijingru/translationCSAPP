[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1280
PlayResY: 720

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: ../../../../Desktop/csapp/Lecture 07  Machine Level Programming III  Procedures.mp4
Video File: ../../../../Desktop/csapp/Lecture 07  Machine Level Programming III  Procedures.mp4
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 1.062500
Scroll Position: 768
Active Line: 781
Video Position: 119863

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: English,Source Han Sans CN,30,&H00FFFFFF,&H00412A2C,&H00412A2C,&H00412A2C,0,0,0,0,100,100,0,0,1,2.2,1,2,10,10,10,1
Style: Chinese,Source Han Sans CN,34,&H00FBFD00,&H00FFFFFF,&H00362A28,&H00FFFFFF,0,0,0,0,100,100,0,0,1,2,0.2,2,10,10,10,1

[Events]
Dialogue: 0,0:00:00.00,0:00:07.96,English,,0,0,0,,We're still slogging through the material on machine level programming which is I talked to you earlier
Dialogue: 0,0:00:00.00,0:00:07.96,Chinese,,0,0,0,,我们仍在讨论机器级编程的材料内容
Dialogue: 0,0:00:07.96,0:00:14.18,English,,0,0,0,,I think is in some ways the core of this course that much of the rest of material builds upon
Dialogue: 0,0:00:07.96,0:00:14.18,Chinese,,0,0,0,,之前提到这些内容是本课程的核心，其余大部分材料内容都是建立在其上的
Dialogue: 0,0:00:14.72,0:00:21.00,English,,0,0,0,,And hopefully you've all had a chance to check out lab2 and your bomb lab
Dialogue: 0,0:00:14.72,0:00:21.00,Chinese,,0,0,0,,希望你们都看了 lab2 和 bomb lab
Dialogue: 0,0:00:21.00,0:00:23.38,English,,0,0,0,,And you've gotten started on that
Dialogue: 0,0:00:21.00,0:00:23.38,Chinese,,0,0,0,,并且已经开始做了
Dialogue: 0,0:00:23.76,0:00:27.96,English,,0,0,0,,And certainly by the time you're finished with the material from today
Dialogue: 0,0:00:23.76,0:00:27.96,Chinese,,0,0,0,,当你在完成今天的内容之后
Dialogue: 0,0:00:28.34,0:00:34.12,English,,0,0,0,,You will be well on the way to solving all but the last one or two stages of the bomb lab
Dialogue: 0,0:00:28.34,0:00:34.12,Chinese,,0,0,0,,除了 bomb lab 的最后一个或两个阶段之外，你将很好地解决所有问题
Dialogue: 0,0:00:34.16,0:00:39.76,English,,0,0,0,,So I highly recommend you get going on that not put it off to the last minute
Dialogue: 0,0:00:34.16,0:00:39.76,Chinese,,0,0,0,,所以我强烈建议你抓紧做，不要把它放到最后一分钟
Dialogue: 0,0:00:40.80,0:00:50.86,English,,0,0,0,,So and what we're talking about today is how procedures, I'm going to use the same terminology here
Dialogue: 0,0:00:40.80,0:00:50.86,Chinese,,0,0,0,,那么我们今天谈论的是过程，我将在这里使用相同的术语
Dialogue: 0,0:00:51.44,0:00:56.96,English,,0,0,0,,Whether it's a function a procedure or an object-oriented programming a method
Dialogue: 0,0:00:51.44,0:00:56.96,Chinese,,0,0,0,,无论是函数过程还是面向对象编程方法
Dialogue: 0,0:00:57.24,0:01:02.12,English,,0,0,0,,Those are all roughly the same thing and what we'll talk about covers them overall
Dialogue: 0,0:00:57.24,0:01:02.12,Chinese,,0,0,0,,这些都是大致相同的事情，今天的讲座都会覆盖到
Dialogue: 0,0:01:08.66,0:01:23.94,English,,0,0,0,,I'll also mention at the outset that the way this is handled in the procedures That we'll be talking about today is a combination of the actual x86 hardware and how it supports it
Dialogue: 0,0:01:08.66,0:01:23.94,Chinese,,0,0,0,,我在最开始还要提到，过程处理这些问题的方式依赖于 x86 硬件的支持
Dialogue: 0,0:01:24.34,0:01:30.11,English,,0,0,0,,But also in some ways more importantly a set of conventions that were developed that
Dialogue: 0,0:01:24.34,0:01:30.11,Chinese,,0,0,0,,但更重要的是一套被普遍承认的公约的建立
Dialogue: 0,0:01:30.64,0:01:34.64,English,,0,0,0,,Basically everyone agreed to and it's known as an ABI
Dialogue: 0,0:01:30.64,0:01:34.64,Chinese,,0,0,0,,它被称为ABI
Dialogue: 0,0:01:34.96,0:01:40.18,English,,0,0,0,,But I want...who stands for application binary interface
Dialogue: 0,0:01:34.96,0:01:40.18,Chinese,,0,0,0,,全称是应用二进制接口
Dialogue: 0,0:01:49.64,0:01:53.94,English,,0,0,0,,So the idea is a document you can get it online
Dialogue: 0,0:01:49.64,0:01:53.94,Chinese,,0,0,0,,你可以在网上获取该文件
Dialogue: 0,0:01:54.26,0:01:57.12,English,,0,0,0,,And it's cited in the book
Dialogue: 0,0:01:54.26,0:01:57.12,Chinese,,0,0,0,,在书中也有引用
Dialogue: 0,0:01:57.80,0:02:06.27,English,,0,0,0,,It's a document that people put together the initial version When the first x86-64 machines were first being developed
Dialogue: 0,0:01:57.80,0:02:06.27,Chinese,,0,0,0,,这是当第一台x86-64机器被开发时人们整理的初始文档
Dialogue: 0,0:02:06.92,0:02:08.90,English,,0,0,0,,And specifically for Linux
Dialogue: 0,0:02:06.92,0:02:08.90,Chinese,,0,0,0,,特别是对于Linux
Dialogue: 0,0:02:09.42,0:02:18.40,English,,0,0,0,,They said okay all Linux programs, all compilers,all the operating system,all the different parts of a system
Dialogue: 0,0:02:09.42,0:02:18.40,Chinese,,0,0,0,,所有Linux程序，所有编译器，所有操作系统，系统的所有不同部分
Dialogue: 0,0:02:18.40,0:02:24.58,English,,0,0,0,,That need to have some common understanding of how to manage the resources on the machine
Dialogue: 0,0:02:18.40,0:02:24.58,Chinese,,0,0,0,,这需要对如何管理机器上的资源有一些共同的理解
Dialogue: 0,0:02:24.98,0:02:27.36,English,,0,0,0,,Will agree to adhere to this set of rules
Dialogue: 0,0:02:24.98,0:02:27.36,Chinese,,0,0,0,,将同意遵守这套规则
Dialogue: 0,0:02:28.16,0:02:35.16,English,,0,0,0,,And so it goes beyond the actual what the hardware does to a set of software standards
Dialogue: 0,0:02:28.16,0:02:35.16,Chinese,,0,0,0,,因此，它超越了硬件对一组软件标准的实际作用
Dialogue: 0,0:02:35.92,0:02:38.32,English,,0,0,0,,And it's called application binary interface
Dialogue: 0,0:02:35.92,0:02:38.32,Chinese,,0,0,0,,它被称为应用程序二进制接口
Dialogue: 0,0:02:38.38,0:02:45.58,English,,0,0,0,,Because it's particularly the interface at the machine program level
Dialogue: 0,0:02:38.38,0:02:45.58,Chinese,,0,0,0,,特别地，因为它是机器程序级别的接口
Dialogue: 0,0:02:46.30,0:02:48.22,English,,0,0,0,,And so that's what we'll be covering today
Dialogue: 0,0:02:46.30,0:02:48.22,Chinese,,0,0,0,,这就是我们今天要介绍的内容
Dialogue: 0,0:02:48.22,0:02:52.66,English,,0,0,0,,So people asked sort of well you know who makes up these rules and things
Dialogue: 0,0:02:48.22,0:02:52.66,Chinese,,0,0,0,,所以人们问你知道谁制定了这些规则和事情
Dialogue: 0,0:02:52.66,0:02:55.34,English,,0,0,0,,And the point was there was a working group that did this
Dialogue: 0,0:02:52.66,0:02:55.34,Chinese,,0,0,0,,关键是有一个工作组做到了这一点
Dialogue: 0,0:02:55.80,0:02:58.12,English,,0,0,0,,And there's a separate ABI for windows
Dialogue: 0,0:02:55.80,0:02:58.12,Chinese,,0,0,0,,Windows还有一个单独的ABI
Dialogue: 0,0:02:58.60,0:03:04.46,English,,0,0,0,,It's similar but not quite the same there's a separate ABI for OSX for apple
Dialogue: 0,0:02:58.60,0:03:04.46,Chinese,,0,0,0,,它类似但不完全相同，它为苹果的OSX提供了单独的ABI
Dialogue: 0,0:03:05.00,0:03:16.96,English,,0,0,0,,And even freebsd a different variant of a UNIX like operating system has its own ABI that they all share a lot in common but some of the details differ
Dialogue: 0,0:03:05.00,0:03:16.96,Chinese,,0,0,0,,甚至freebsd，UNIX操作系统的另一种变体 有自己的ABI，他们都有很多共同点，但有些细节不同
Dialogue: 0,0:03:19.76,0:03:28.08,English,,0,0,0,,Um so if you think about what goes on in a procedure even in C which is a relatively unsophisticated language in many ways
Dialogue: 0,0:03:19.76,0:03:28.08,Chinese,,0,0,0,,如果你思考在过程中发生了什么，即便对于C这种相对简单的语言
Dialogue: 0,0:03:28.60,0:03:33.74,English,,0,0,0,,There's a lot going on and so it's worth breaking down those and thinking about it
Dialogue: 0,0:03:28.60,0:03:33.74,Chinese,,0,0,0,,有很多事情要发生，所以值得打破分解这些并思考它
Dialogue: 0,0:03:34.20,0:03:36.34,English,,0,0,0,,One is there's a notion of control
Dialogue: 0,0:03:34.20,0:03:36.34,Chinese,,0,0,0,,一个是控制概念
Dialogue: 0,0:03:36.68,0:03:40.96,English,,0,0,0,,So in my example I show a procedure P calling a procedure Q
Dialogue: 0,0:03:36.68,0:03:40.96,Chinese,,0,0,0,,所以在我的例子中，我展示了一个程序P调用程序Q.
Dialogue: 0,0:03:41.58,0:03:52.32,English,,0,0,0,,And so when P calls Q then somehow the program has to jump down and begin executing the the lines of code for Q
Dialogue: 0,0:03:41.58,0:03:52.32,Chinese,,0,0,0,,所以当P调用Q后程序必须以某种方式跳转并开始执行Q的代码
Dialogue: 0,0:03:52.70,0:03:59.36,English,,0,0,0,,And then when Q hits its exit point its return point, somehow is to get back to P
Dialogue: 0,0:03:52.70,0:03:59.36,Chinese,,0,0,0,,然后当Q执行到它的返回点，需要以某种方式回到P
Dialogue: 0,0:03:59.62,0:04:06.80,English,,0,0,0,,And not just to any old place in P, but specifically to whatever comes in P right after the call to Q
Dialogue: 0,0:03:59.62,0:04:06.80,Chinese,,0,0,0,,不是返回到P的任何地方都可以，必须恰好在P调用Q后的位置
Dialogue: 0,0:04:07.72,0:04:15.00,English,,0,0,0,,So somehow we have to record the information about where the return should be to return to the correct place
Dialogue: 0,0:04:07.72,0:04:15.00,Chinese,,0,0,0,,因此为了返回到正确的位置，我们需要记录返回位置的信息
Dialogue: 0,0:04:15.62,0:04:23.30,English,,0,0,0,,So that's first of all.To for passing control to a function and having that function return back to where it should get back to
Dialogue: 0,0:04:15.62,0:04:23.30,Chinese,,0,0,0,,首先，我们需要转移控制给函数并使它返回到正确的位置
Dialogue: 0,0:04:24.54,0:04:29.08,English,,0,0,0,,Our second there is data, how do we get operands to it
Dialogue: 0,0:04:24.54,0:04:29.08,Chinese,,0,0,0,,第二个问题是数据，即我们如何传递参数
Dialogue: 0,0:04:29.08,0:04:30.76,English,,0,0,0,,So in this particular case
Dialogue: 0,0:04:29.08,0:04:30.76,Chinese,,0,0,0,,所以在这种特殊情况下
Dialogue: 0,0:04:31.38,0:04:36.18,English,,0,0,0,,Q is a function that takes a single argument that it calls internally it calls i
Dialogue: 0,0:04:31.38,0:04:36.18,Chinese,,0,0,0,,Q是一个函数，它接受一个在内部调用它调用i的参数
Dialogue: 0,0:04:36.90,0:04:42.12,English,,0,0,0,,And up here where P is calling it,it's passing some value within P called x
Dialogue: 0,0:04:36.90,0:04:42.12,Chinese,,0,0,0,,在P调用它的地方，它在P中传递了一些值x
Dialogue: 0,0:04:42.82,0:04:48.00,English,,0,0,0,,So somehow that data value of x has to be recorded in a form
Dialogue: 0,0:04:42.82,0:04:48.00,Chinese,,0,0,0,,所以x的数据值必须以某种形式记录
Dialogue: 0,0:04:48.36,0:04:51.92,English,,0,0,0,,That within Q it will have access to that information
Dialogue: 0,0:04:48.36,0:04:51.92,Chinese,,0,0,0,,在Q内，它将有权访问该信息
Dialogue: 0,0:04:52.24,0:05:00.78,English,,0,0,0,,And similarly when Q wants to return a value back and then P will make use of that value
Dialogue: 0,0:04:52.24,0:05:00.78,Chinese,,0,0,0,,同样，当Q想要返回一个值时P将利用该值
Dialogue: 0,0:05:00.78,0:05:05.46,English,,0,0,0,,There has to be some convention of how that data gets communicated back
Dialogue: 0,0:05:00.78,0:05:05.46,Chinese,,0,0,0,,必须有一些关于如何传回数据的惯例
Dialogue: 0,0:05:07.34,0:05:11.68,English,,0,0,0,,And then finally in a function might have some local data
Dialogue: 0,0:05:07.34,0:05:11.68,Chinese,,0,0,0,,最后一点，在一个函数中可能会有一些局部数据
Dialogue: 0,0:05:12.15,0:05:16.42,English,,0,0,0,,That requires allocation of some amount of space
Dialogue: 0,0:05:12.15,0:05:16.42,Chinese,,0,0,0,,这需要分配一些空间
Dialogue: 0,0:05:16.96,0:05:21.64,English,,0,0,0,,And so where does that space get allocated.How do we make sure it gets allocated properly?
Dialogue: 0,0:05:16.96,0:05:21.64,Chinese,,0,0,0,,那么这个空间在哪里被分配、如何确保它被正确分配？
Dialogue: 0,0:05:22.18,0:05:31.62,English,,0,0,0,,In particular in C as you know when a function returns any local data that it allocated should get deallocated should be freed up
Dialogue: 0,0:05:22.18,0:05:31.62,Chinese,,0,0,0,,特别地，在C中局部变量被返回的同时应该被释放
Dialogue: 0,0:05:31.74,0:05:36.44,English,,0,0,0,,So that we don't sort of start consuming an unbounded amount of storage
Dialogue: 0,0:05:31.74,0:05:36.44,Chinese,,0,0,0,,这确保我们不会消耗无限量的存储空间
Dialogue: 0,0:05:37.08,0:05:38.00,English,,0,0,0,,So how do we do that
Dialogue: 0,0:05:37.08,0:05:38.00,Chinese,,0,0,0,,那我们该怎么做呢
Dialogue: 0,0:05:38.02,0:05:44.80,English,,0,0,0,,Those are all the sort of different aspects that a procedure call in return I have to deal with somehow
Dialogue: 0,0:05:38.02,0:05:44.80,Chinese,,0,0,0,,这些都是过程调用的不同方面，之后我都会讲到
Dialogue: 0,0:05:45.52,0:05:50.18,English,,0,0,0,,And part of the reason for breaking it down into those little segments is
Dialogue: 0,0:05:45.52,0:05:50.18,Chinese,,0,0,0,,将其分解为那些小部分的部分原因是
Dialogue: 0,0:05:50.62,0:05:59.50,English,,0,0,0,,In x86-64,one of the clever things they did was to try and reduce the overhead of procedure calls as much as possible
Dialogue: 0,0:05:50.62,0:05:59.50,Chinese,,0,0,0,,在x86-64中，他们做的一件聪明的事情就是尽可能地减少过程调用的开销
Dialogue: 0,0:05:59.50,0:06:09.12,English,,0,0,0,,Because as you know in good programming style you often write these functions that do a fairly small amount of actual useful stuff
Dialogue: 0,0:05:59.50,0:06:09.12,Chinese,,0,0,0,,因为在好的编程风格中你经常写实际上只有很少用途的函数
Dialogue: 0,0:06:09.80,0:06:16.40,English,,0,0,0,,And it's sort of good programming style to do that especially in a more object-oriented programming style
Dialogue: 0,0:06:09.80,0:06:16.40,Chinese,,0,0,0,,特别地，在面向对象编程中更需要好的编程风格
Dialogue: 0,0:06:17.06,0:06:27.30,English,,0,0,0,,And so you don't want the overhead the extra number of steps taken to nvoke a procedure and deal with all those aspects to take any more time than it needs to
Dialogue: 0,0:06:17.06,0:06:27.30,Chinese,,0,0,0,,你不希望因为这些额外的步骤调用过程，导致花费更多的时间
Dialogue: 0,0:06:27.30,0:06:30.42,English,,0,0,0,,Because it's a fairly critical overhead
Dialogue: 0,0:06:27.30,0:06:30.42,Chinese,,0,0,0,,因为这是一个相当关键的开销
Dialogue: 0,0:06:31.44,0:06:37.46,English,,0,0,0,,So one of the things they do in this, they only do whatever is absolutely needed
Dialogue: 0,0:06:31.44,0:06:37.46,Chinese,,0,0,0,,为此他们只做了绝对需要的事情
Dialogue: 0,0:06:37.94,0:06:45.94,English,,0,0,0,,So hurt in particular if no local storage is needed on this for data then don't allocate it therefore don't free it
Dialogue: 0,0:06:37.94,0:06:45.94,Chinese,,0,0,0,,如果数据不需要本地存储空间则不要分配和释放空间了
Dialogue: 0,0:06:46.38,0:06:49.54,English,,0,0,0,,If you're not passing any values don't pass them
Dialogue: 0,0:06:46.38,0:06:49.54,Chinese,,0,0,0,,如果你没有传递任何值则不要传递它们
Dialogue: 0,0:06:49.96,0:06:54.12,English,,0,0,0,,And in general sort of how little can you get away with
Dialogue: 0,0:06:49.96,0:06:54.12,Chinese,,0,0,0,,总之就是尽可能规避开销
Dialogue: 0,0:06:54.32,0:06:58.38,English,,0,0,0,,And that makes it a little bit confusing from a teaching point of view
Dialogue: 0,0:06:54.32,0:06:58.38,Chinese,,0,0,0,,从教学的角度来看，这有点令人困惑
Dialogue: 0,0:06:58.38,0:07:01.87,English,,0,0,0,,And that there is no set template that it follows every time
Dialogue: 0,0:06:58.38,0:07:01.87,Chinese,,0,0,0,,并且每次都没有固定的模板
Dialogue: 0,0:07:01.94,0:07:08.34,English,,0,0,0,,It sort of you have to each case is a special case for how a particular procedure gets implemented
Dialogue: 0,0:07:01.94,0:07:08.34,Chinese,,0,0,0,,在每种情况中，过程的执行都是需要具体分析的
Dialogue: 0,0:07:11.28,0:07:15.02,English,,0,0,0,,So we'll go through all these parts and see how they happen
Dialogue: 0,0:07:11.28,0:07:15.02,Chinese,,0,0,0,,因此，我们将通过这几部分看看它们是如何发生的
Dialogue: 0,0:07:15.02,0:07:17.58,English,,0,0,0,,And you've already seen little glimpses of them
Dialogue: 0,0:07:15.02,0:07:17.58,Chinese,,0,0,0,,你已经看到了一小部分
Dialogue: 0,0:07:17.96,0:07:20.66,English,,0,0,0,,We'll hit the little fragments of code that we've shown already
Dialogue: 0,0:07:17.96,0:07:20.66,Chinese,,0,0,0,,我们将用已经展示过的代码片段为例
Dialogue: 0,0:07:22.38,0:07:29.08,English,,0,0,0,,So the first one and sort of the most critical is how do we pass control to a function
Dialogue: 0,0:07:22.38,0:07:29.08,Chinese,,0,0,0,,所以第一个也是最关键的，是我们如何将控制传递给一个函数
Dialogue: 0,0:07:29.30,0:07:32.52,English,,0,0,0,,But before we can even talk about that we have to talk about the stack
Dialogue: 0,0:07:29.30,0:07:32.52,Chinese,,0,0,0,,但在我们谈论之前我们不得不谈论栈
Dialogue: 0,0:07:34.06,0:07:37.08,English,,0,0,0,,So and you've heard that term the stack in various ways
Dialogue: 0,0:07:34.06,0:07:37.08,Chinese,,0,0,0,,你已经以各种方式听到了这个术语
Dialogue: 0,0:07:37.56,0:07:41.08,English,,0,0,0,,The stack is really not a special memory
Dialogue: 0,0:07:37.56,0:07:41.08,Chinese,,0,0,0,,堆栈实际上不是特殊的内存
Dialogue: 0,0:07:41.30,0:07:43.76,English,,0,0,0,,It's just a region of the normal memory
Dialogue: 0,0:07:41.30,0:07:43.76,Chinese,,0,0,0,,它只是正常记忆的一个区域
Dialogue: 0,0:07:44.14,0:07:52.74,English,,0,0,0,,Remember to the programmers perspective assembly level programmers perspective is memory is just a big array of bytes
Dialogue: 0,0:07:44.14,0:07:52.74,Chinese,,0,0,0,,对于汇编层面的程序员而言，内存只是一个巨大的字节数组
Dialogue: 0,0:07:53.84,0:07:58.24,English,,0,0,0,,And somewhere within that bunch of bytes,we're going to call it the stack
Dialogue: 0,0:07:53.84,0:07:58.24,Chinese,,0,0,0,,在那一堆字节中的某个地方，我们将其称为栈
Dialogue: 0,0:07:59.02,0:08:08.00,English,,0,0,0,,And the stack is used by the program to manage the state associated with the procedures that it calls and as they return
Dialogue: 0,0:07:59.02,0:08:08.00,Chinese,,0,0,0,,程序用栈来管理过程调用与返回的状态
Dialogue: 0,0:08:08.14,0:08:18.90,English,,0,0,0,,So it's where it passes all these potential information the control information data and allocates local data
Dialogue: 0,0:08:08.14,0:08:18.90,Chinese,,0,0,0,,在栈中，程序传递潜在信息，控制信息和数据并分配本地数据。
Dialogue: 0,0:08:19.32,0:08:21.62,English,,0,0,0,,And the reason why it can be managed is a stack
Dialogue: 0,0:08:19.32,0:08:21.62,Chinese,,0,0,0,,它可以被管理的原因是栈
Dialogue: 0,0:08:21.66,0:08:26.74,English,,0,0,0,,Because of the nature of the whole idea of procedure calls and returns
Dialogue: 0,0:08:21.66,0:08:26.74,Chinese,,0,0,0,,由于程序调用和返回的整个想法的实质
Dialogue: 0,0:08:26.74,0:08:30.42,English,,0,0,0,,That you make a call and you might need some information
Dialogue: 0,0:08:26.74,0:08:30.42,Chinese,,0,0,0,,当你调用时，可能需要一些信息
Dialogue: 0,0:08:30.80,0:08:35.01,English,,0,0,0,,But when you return from a call, all that information can be discarded
Dialogue: 0,0:08:30.80,0:08:35.01,Chinese,,0,0,0,,但是当你从调用中返回时，所有这些信息都可以被丢弃
Dialogue: 0,0:08:36.38,0:08:41.62,English,,0,0,0,,And so it makes use of that sort of last in first out allocation principle
Dialogue: 0,0:08:36.38,0:08:41.62,Chinese,,0,0,0,,因此它利用了那种后进先出的原则
Dialogue: 0,0:08:41.94,0:08:45.22,English,,0,0,0,,Meshes very well with this idea of procedure call and return
Dialogue: 0,0:08:41.94,0:08:45.22,Chinese,,0,0,0,,这与调用与返回的思想十分吻合
Dialogue: 0,0:08:46.30,0:08:49.36,English,,0,0,0,,So in x86 stacks
Dialogue: 0,0:08:46.30,0:08:49.36,Chinese,,0,0,0,,所以在x86栈中
Dialogue: 0,0:08:50.20,0:08:53.28,English,,0,0,0,,Actually start with a very high numbered address
Dialogue: 0,0:08:50.20,0:08:53.28,Chinese,,0,0,0,,实际上从一个非常高的编号地址开始
Dialogue: 0,0:08:54.10,0:08:59.60,English,,0,0,0,,And when they grow when more data are allocated for the stack
Dialogue: 0,0:08:54.10,0:08:59.60,Chinese,,0,0,0,,当栈生长时，更多的数据分配给栈
Dialogue: 0,0:08:59.60,0:09:03.20,English,,0,0,0,,It's done by decrementing the stack pointer
Dialogue: 0,0:08:59.60,0:09:03.20,Chinese,,0,0,0,,这是通过递减栈指针来完成的
Dialogue: 0,0:09:03.20,0:09:08.02,English,,0,0,0,,So the stack pointer as you know is just a regular register %rsp
Dialogue: 0,0:09:03.20,0:09:08.02,Chinese,,0,0,0,,所以栈指针只是一个常规寄存器％rsp
Dialogue: 0,0:09:08.68,0:09:12.64,English,,0,0,0,,And its value is the address of the current top of the stack
Dialogue: 0,0:09:08.68,0:09:12.64,Chinese,,0,0,0,,它的值是当前栈顶部的地址
Dialogue: 0,0:09:13.30,0:09:18.10,English,,0,0,0,,And every time you allocate more space on the stack it does by decrementing that pointer
Dialogue: 0,0:09:13.30,0:09:18.10,Chinese,,0,0,0,,每次在栈上分配更多空间时，都会通过递减该指针来实现
Dialogue: 0,0:09:18.80,0:09:21.22,English,,0,0,0,,Now just for convention
Dialogue: 0,0:09:18.80,0:09:21.22,Chinese,,0,0,0,,现在只是为了惯例
Dialogue: 0,0:09:23.44,0:09:26.67,English,,0,0,0,,And I'm not sure why this happens but this is the way we do it
Dialogue: 0,0:09:23.44,0:09:26.67,Chinese,,0,0,0,,而且我不确定为什么会这样，但这就是我们这样做的方式
Dialogue: 0,0:09:27.30,0:09:29.70,English,,0,0,0,,Is we draw stacks upside down
Dialogue: 0,0:09:27.30,0:09:29.70,Chinese,,0,0,0,,我们倒着画栈
Dialogue: 0,0:09:30.10,0:09:35.94,English,,0,0,0,,So the top of the stack is actually shown at the bottom
Dialogue: 0,0:09:30.10,0:09:35.94,Chinese,,0,0,0,,所以栈的顶部实际显示在底部
Dialogue: 0,0:09:38.52,0:09:42.10,English,,0,0,0,,And just to add to that confusion
Dialogue: 0,0:09:38.52,0:09:42.10,Chinese,,0,0,0,,只是为了增加这种混乱
Dialogue: 0,0:09:42.10,0:09:48.80,English,,0,0,0,,And also remember that the addresses go from bottom to top, not from top to bottom
Dialogue: 0,0:09:42.10,0:09:48.80,Chinese,,0,0,0,,还记得地址从下到上，而不是从上到下
Dialogue: 0,0:09:48.80,0:09:52.44,English,,0,0,0,,So when you add to the stack you decrement the stack pointer
Dialogue: 0,0:09:48.80,0:09:52.44,Chinese,,0,0,0,,因此，当你添加到堆栈时，你将减少栈指针
Dialogue: 0,0:09:53.04,0:09:56.46,English,,0,0,0,,Neither of those kind of meshes with your intuition perhaps
Dialogue: 0,0:09:53.04,0:09:56.46,Chinese,,0,0,0,,也许这些都与你的直觉不相符
Dialogue: 0,0:09:56.46,0:10:01.14,English,,0,0,0,,But you just have to get used to it,because we're not going to redraw out all the slides
Dialogue: 0,0:09:56.46,0:10:01.14,Chinese,,0,0,0,,但你只需要习惯它，因为我们不会重新绘制所有幻灯片
Dialogue: 0,0:10:04.70,0:10:09.62,English,,0,0,0,,So anyway sets just remember that over and over again
Dialogue: 0,0:10:04.70,0:10:09.62,Chinese,,0,0,0,,所以无论如何都要一遍又一遍地记住
Dialogue: 0,0:10:09.62,0:10:11.70,English,,0,0,0,,That's why this arrow show that
Dialogue: 0,0:10:09.62,0:10:11.70,Chinese,,0,0,0,,这就是为什么这个箭头强调了这一点
Dialogue: 0,0:10:12.20,0:10:16.06,English,,0,0,0,,If we were to enumerate the addresses of these different bytes in the data
Dialogue: 0,0:10:12.20,0:10:16.06,Chinese,,0,0,0,,如果我们要枚举数据中这些不同字节的地址
Dialogue: 0,0:10:16.06,0:10:20.80,English,,0,0,0,,They'd be increasing in this direction and when we add to the stack
Dialogue: 0,0:10:16.06,0:10:20.80,Chinese,,0,0,0,,当我们向栈中添加数据时，地址会朝这个方向增加
Dialogue: 0,0:10:21.32,0:10:26.54,English,,0,0,0,,The stack top is at the bottom of the picture and we do it by decrementing the stack pointer
Dialogue: 0,0:10:21.32,0:10:26.54,Chinese,,0,0,0,,堆栈顶部位于图片的底部，我们通过递减堆栈指针来完成
Dialogue: 0,0:10:28.42,0:10:37.08,English,,0,0,0,,So in particular there is explicit instructions push and pop that make use of the stack
Dialogue: 0,0:10:28.42,0:10:37.08,Chinese,,0,0,0,,特别地，有操作栈的显式指令push和pop
Dialogue: 0,0:10:37.62,0:10:41.28,English,,0,0,0,,And it's often written pushq and popq
Dialogue: 0,0:10:37.62,0:10:41.28,Chinese,,0,0,0,,它经常写成pushq和popq
Dialogue: 0,0:10:41.62,0:10:47.56,English,,0,0,0,,But that q is actually a an optional suffix on the instruction
Dialogue: 0,0:10:41.62,0:10:47.56,Chinese,,0,0,0,,但是q实际上是指令的可选后缀
Dialogue: 0,0:10:48.69,0:10:51.94,English,,0,0,0,,So the idea of pushing something onto the stack
Dialogue: 0,0:10:48.69,0:10:51.94,Chinese,,0,0,0,,所以这就是push操作的思想
Dialogue: 0,0:10:52.02,0:11:00.66,English,,0,0,0,,Then is,there is some source operand it could be from register or from memory or an immediate
Dialogue: 0,0:10:52.02,0:11:00.66,Chinese,,0,0,0,,然后，有一些源操作数可以来自寄存器或内存或立即数
Dialogue: 0,0:11:01.16,0:11:03.22,English,,0,0,0,,So this is sort of like a move instruction
Dialogue: 0,0:11:01.16,0:11:03.22,Chinese,,0,0,0,,所以这有点像移动指令
Dialogue: 0,0:11:03.22,0:11:07.80,English,,0,0,0,,But the destination of the move will be toward memory
Dialogue: 0,0:11:03.22,0:11:07.80,Chinese,,0,0,0,,但移动的目的地是内存
Dialogue: 0,0:11:08.26,0:11:14.86,English,,0,0,0,,And that address of the memory is determined by first decrementing the stack pointer and then doing a write
Dialogue: 0,0:11:08.26,0:11:14.86,Chinese,,0,0,0,,内存地址通过首先递减堆栈指针然后执行写操作来确定
Dialogue: 0,0:11:20.02,0:11:24.68,English,,0,0,0,,And similarly the pop instruction takes reads data from the stack
Dialogue: 0,0:11:20.02,0:11:24.68,Chinese,,0,0,0,,类似地，pop指令从堆栈中读取数据
Dialogue: 0,0:11:24.68,0:11:30.48,English,,0,0,0,,And stores it in the destination which must be a register for this particular instruction
Dialogue: 0,0:11:24.68,0:11:30.48,Chinese,,0,0,0,,并将其存储在目标中，对该指令而言目标必须是寄存器
Dialogue: 0,0:11:31.24,0:11:38.88,English,,0,0,0,,I think push must be a register too, now that I think of it or immediate, you can't push from memory to
Dialogue: 0,0:11:31.24,0:11:38.88,Chinese,,0,0,0,,我认为push操作的目标也是一个寄存器或者立即数，你不能将内存中数据直接放入栈中
Dialogue: 0,0:11:40.56,0:11:43.50,English,,0,0,0,,So pop reads from memory
Dialogue: 0,0:11:40.56,0:11:43.50,Chinese,,0,0,0,,所以pop从内存中读取
Dialogue: 0,0:11:43.80,0:11:47.70,English,,0,0,0,,The address it reads from is given by the current stack pointer
Dialogue: 0,0:11:43.80,0:11:47.70,Chinese,,0,0,0,,它读取的地址由当前堆栈指针给出
Dialogue: 0,0:11:48.82,0:11:52.14,English,,0,0,0,,and then it increments the stack pointer by 8
Dialogue: 0,0:11:48.82,0:11:52.14,Chinese,,0,0,0,,然后它将堆栈指针递增8
Dialogue: 0,0:11:52.40,0:11:56.48,English,,0,0,0,,These both work only on 8 byte operands I'll get to you in a second and
Dialogue: 0,0:11:52.40,0:11:56.48,Chinese,,0,0,0,,这些都只适用于8字节操作数，我一会儿将要提到
Dialogue: 0,0:11:57.02,0:12:01.42,English,,0,0,0,,Then the result of that is stored in a register
Dialogue: 0,0:11:57.02,0:12:01.42,Chinese,,0,0,0,,然后将其结果存储在寄存器中
Dialogue: 0,0:12:02.02,0:12:02.42,English,,0,0,0,,Question
Dialogue: 0,0:12:02.02,0:12:02.42,Chinese,,0,0,0,,有问题吗
Dialogue: 0,0:12:03.54,0:12:14.70,English,,0,0,0,,...pop and push or just like doing the the three things like is, there a difference between like using the like the top
Dialogue: 0,0:12:03.54,0:12:14.70,Chinese,,0,0,0,,pop和push或者就像做三件事情一样，只有使用顶部的区别？
Dialogue: 0,0:12:14.74,0:12:17.12,English,,0,0,0,,Oh could you write it as a set of instructions
Dialogue: 0,0:12:14.74,0:12:17.12,Chinese,,0,0,0,,哦，你能把它写成一套指令吗？
Dialogue: 0,0:12:17.66,0:12:25.14,English,,0,0,0,,Yeah you could actually except for some weird corner cases write it out as a set of separate instructions
Dialogue: 0,0:12:17.66,0:12:25.14,Chinese,,0,0,0,,是的。除了一些奇怪的特例，你可以将其作为一组分开的指令写出来
Dialogue: 0,0:12:25.80,0:12:31.92,English,,0,0,0,,But it's a common enough thing that it's sort of built in as a as an operation
Dialogue: 0,0:12:25.80,0:12:31.92,Chinese,,0,0,0,,但这很普遍，就是内置在操作中的
Dialogue: 0,0:12:32.66,0:12:36.80,English,,0,0,0,,Whereas call and returner are special they can't be simulated
Dialogue: 0,0:12:32.66,0:12:36.80,Chinese,,0,0,0,,然而call与ret指令比较特殊，它们不能被模拟
Dialogue: 0,0:12:37.22,0:12:40.58,English,,0,0,0,,So one thing do you remember too is it's important that
Dialogue: 0,0:12:37.22,0:12:40.58,Chinese,,0,0,0,,另一件事情很重要，你也需要记住
Dialogue: 0,0:12:41.18,0:12:47.10,English,,0,0,0,,In one case you decrement you do the arithmetic on the stack pointer before you write
Dialogue: 0,0:12:41.18,0:12:47.10,Chinese,,0,0,0,,在一种情况下，在写入之前要对栈指针进行算术运算
Dialogue: 0,0:12:47.78,0:12:49.72,English,,0,0,0,,Because when you first start it out
Dialogue: 0,0:12:47.78,0:12:49.72,Chinese,,0,0,0,,因为当你第一次开始时
Dialogue: 0,0:12:49.72,0:12:53.30,English,,0,0,0,,The stack pointer is pointing to whatever was the top element of the stack
Dialogue: 0,0:12:49.72,0:12:53.30,Chinese,,0,0,0,,栈指针指向原本的栈顶元素
Dialogue: 0,0:12:54.00,0:12:59.47,English,,0,0,0,,We want to create a new top element so we're going to decrement first and then do the write
Dialogue: 0,0:12:54.00,0:12:59.47,Chinese,,0,0,0,,我们想创建一个新的栈顶元素，所以我们先减少再写入
Dialogue: 0,0:13:00.10,0:13:05.60,English,,0,0,0,,Whereas going the other direction you want to read off the current top of stack element
Dialogue: 0,0:13:00.10,0:13:05.60,Chinese,,0,0,0,,另一种情况，你想读取目前的栈顶元素
Dialogue: 0,0:13:05.96,0:13:10.72,English,,0,0,0,,And then you want to increment the stack pointer to sort of deallocate it
Dialogue: 0,0:13:05.96,0:13:10.72,Chinese,,0,0,0,,然后你想增加栈指针来释放空间
Dialogue: 0,0:13:11.10,0:13:13.76,English,,0,0,0,,And one thing you'll notice here is when I say deallocate
Dialogue: 0,0:13:11.10,0:13:13.76,Chinese,,0,0,0,,注意到当我说“释放”的时候
Dialogue: 0,0:13:13.76,0:13:20.08,English,,0,0,0,,It's not like I magically erase this or something all I'm doing is just moving a stack pointer
Dialogue: 0,0:13:13.76,0:13:20.08,Chinese,,0,0,0,,并不意味着我神奇地抹去了什么，我仅仅移动了栈指针
Dialogue: 0,0:13:20.08,0:13:24.60,English,,0,0,0,,Whatever it was there at the top of the stack is still in memory
Dialogue: 0,0:13:20.08,0:13:24.60,Chinese,,0,0,0,,栈顶元素仍然保留在内存中
Dialogue: 0,0:13:24.90,0:13:27.22,English,,0,0,0,,It's just no longer considered part of the stack
Dialogue: 0,0:13:24.90,0:13:27.22,Chinese,,0,0,0,,只是不再是栈的一部分了
Dialogue: 0,0:13:32.10,0:13:34.72,English,,0,0,0,,Okay so that's the idea of the stack
Dialogue: 0,0:13:32.10,0:13:34.72,Chinese,,0,0,0,,好的，这就是栈的思想
Dialogue: 0,0:13:35.22,0:13:41.74,English,,0,0,0,,And the instructions push and pop are to...put data on the stack or take it off
Dialogue: 0,0:13:35.22,0:13:41.74,Chinese,,0,0,0,,而push和pop的指令是为了将数据放入栈或将其取出
Dialogue: 0,0:13:41.80,0:13:45.66,English,,0,0,0,,But we use the same basic idea for a call and return
Dialogue: 0,0:13:41.80,0:13:45.66,Chinese,,0,0,0,,但我们对于指令call与ret使用相同的思想
Dialogue: 0,0:13:49.58,0:13:52.80,English,,0,0,0,,So let's look at some examples and there's a lot of stuff up here
Dialogue: 0,0:13:49.58,0:13:52.80,Chinese,,0,0,0,,那么让我们看看一些例子，这里有很多要讲的
Dialogue: 0,0:13:53.22,0:13:56.56,English,,0,0,0,,But this is a C function called multstore
Dialogue: 0,0:13:53.22,0:13:56.56,Chinese,,0,0,0,,但这是一个名为multstore的C函数
Dialogue: 0,0:13:57.08,0:14:05.00,English,,0,0,0,,And then this is the output slightly cleaned up output from the disassembler of that exact function
Dialogue: 0,0:13:57.08,0:14:05.00,Chinese,,0,0,0,,这是经处理过的反汇编器的输出
Dialogue: 0,0:14:05.74,0:14:08.20,English,,0,0,0,,And similarly this is a function called mult2
Dialogue: 0,0:14:05.74,0:14:08.20,Chinese,,0,0,0,,同样，这是一个名为mult2的函数
Dialogue: 0,0:14:08.88,0:14:10.90,English,,0,0,0,,And this is disassembled version
Dialogue: 0,0:14:08.88,0:14:10.90,Chinese,,0,0,0,,这是反汇编的版本
Dialogue: 0,0:14:11.32,0:14:20.90,English,,0,0,0,,And the reason I'm showing this is,because I want to make use of the addresses that these instructions are at that you don't see when you write it in assembly code
Dialogue: 0,0:14:11.32,0:14:20.90,Chinese,,0,0,0,,我展示这些是为了应用指令所在的地址，而你在汇编代码中是看不到这些的
Dialogue: 0,0:14:20.94,0:14:23.92,English,,0,0,0,,So I'm showing it the disassembled version
Dialogue: 0,0:14:20.94,0:14:23.92,Chinese,,0,0,0,,所以我展示了反汇编的版本
Dialogue: 0,0:14:25.16,0:14:32.10,English,,0,0,0,,And the reason all this is up here is because you'll see the function multstore calls mult2
Dialogue: 0,0:14:25.16,0:14:32.10,Chinese,,0,0,0,,你会看到函数multstore调用mult2
Dialogue: 0,0:14:32.14,0:14:33.84,English,,0,0,0,,So I want to show how that works
Dialogue: 0,0:14:32.14,0:14:33.84,Chinese,,0,0,0,,所以我想通过这些代码展示一下它是如何工作的
Dialogue: 0,0:14:36.10,0:14:41.18,English,,0,0,0,,So and there's two instructions and you've seen these in some form
Dialogue: 0,0:14:36.10,0:14:41.18,Chinese,,0,0,0,,所以，有两个指令你已经以某种形式看到了
Dialogue: 0,0:14:41.72,0:14:45.78,English,,0,0,0,,To call a function you just call it where you give a label
Dialogue: 0,0:14:41.72,0:14:45.78,Chinese,,0,0,0,,要调用一个函数，只需在给出标签的地方调用它
Dialogue: 0,0:14:46.24,0:14:49.30,English,,0,0,0,,But keep in mind that this these two instructions
Dialogue: 0,0:14:46.24,0:14:49.30,Chinese,,0,0,0,,但请记住这两条指令
Dialogue: 0,0:14:49.30,0:14:54.00,English,,0,0,0,,And the other is when you're ready to return you just execute the ret instruction
Dialogue: 0,0:14:49.30,0:14:54.00,Chinese,,0,0,0,,另一种是当你准备好返回时，只需执行ret指令即可
Dialogue: 0,0:14:54.76,0:15:00.94,English,,0,0,0,,And keep in mind though that these functions don't do the whole business of procedure call and return
Dialogue: 0,0:14:54.76,0:15:00.94,Chinese,,0,0,0,,请记住这些函数并不完成调用与返回的全部任务
Dialogue: 0,0:15:00.94,0:15:06.76,English,,0,0,0,,They just do the control part of it which as we saw is only one of three aspects of a procedure
Dialogue: 0,0:15:00.94,0:15:06.76,Chinese,,0,0,0,,它们只是完成了控制部分，正如我们所见，这只是过程三个方面中的一个
Dialogue: 0,0:15:08.36,0:15:16.14,English,,0,0,0,,Also mention you'll see especially in...sometimes it will say rep; ret
Dialogue: 0,0:15:08.36,0:15:16.14,Chinese,,0,0,0,,另外你会看到rep;ret指令
Dialogue: 0,0:15:17.68,0:15:20.06,English,,0,0,0,,And you can pretty much just ignore that
Dialogue: 0,0:15:17.68,0:15:20.06,Chinese,,0,0,0,,你几乎可以忽略它
Dialogue: 0,0:15:21.16,0:15:23.42,English,,0,0,0,,And it's a bit obscure why it's even there
Dialogue: 0,0:15:21.16,0:15:23.42,Chinese,,0,0,0,,它存在的理由不太明确
Dialogue: 0,0:15:23.42,0:15:26.40,English,,0,0,0,,So it's really the same idea
Dialogue: 0,0:15:23.42,0:15:26.40,Chinese,,0,0,0,,把它们当做是一个意思就可以
Dialogue: 0,0:15:30.46,0:15:35.66,English,,0,0,0,,Okay so Let's so to break this down into its simplest part
Dialogue: 0,0:15:30.46,0:15:35.66,Chinese,,0,0,0,,好的，让我们把它分解成最简单的部分
Dialogue: 0,0:15:35.74,0:15:37.68,English,,0,0,0,,So let's imagine a scenario
Dialogue: 0,0:15:35.74,0:15:37.68,Chinese,,0,0,0,,让我们想象一个场景
Dialogue: 0,0:15:38.52,0:15:43.60,English,,0,0,0,,In which the top of stack is at 0x120
Dialogue: 0,0:15:38.52,0:15:43.60,Chinese,,0,0,0,,其中栈顶在0x120
Dialogue: 0,0:15:43.94,0:15:45.86,English,,0,0,0,,Which is not realistic by the way
Dialogue: 0,0:15:43.94,0:15:45.86,Chinese,,0,0,0,,顺便说一下这是不现实的
Dialogue: 0,0:15:46.86,0:15:52.02,English,,0,0,0,,And the program counter which is called %rip which is not anything to do with death
Dialogue: 0,0:15:46.86,0:15:52.02,Chinese,,0,0,0,,程序计数器称为％rip，与死亡无关
Dialogue: 0,0:15:54.04,0:16:00.14,English,,0,0,0,,Is is indicating that the current instruction is this at (0x)544
Dialogue: 0,0:15:54.04,0:16:00.14,Chinese,,0,0,0,,是指示当前指令是（0x）544
Dialogue: 0,0:16:01.86,0:16:03.22,English,,0,0,0,,Which is this call instruction
Dialogue: 0,0:16:01.86,0:16:03.22,Chinese,,0,0,0,,即为这个call指令
Dialogue: 0,0:16:04.68,0:16:10.34,English,,0,0,0,,And so what would happen with the call instruction is it would do two things
Dialogue: 0,0:16:04.68,0:16:10.34,Chinese,,0,0,0,,那么call指令会发生什么呢？它会做两件事
Dialogue: 0,0:16:11.36,0:16:14.28,English,,0,0,0,,It would actually three things
Dialogue: 0,0:16:11.36,0:16:14.28,Chinese,,0,0,0,,实际上会有三件事
Dialogue: 0,0:16:14.28,0:16:21.40,English,,0,0,0,,It would decrement the stack pointer and so subtracting 8 from (0x)120 and hex gives you (0x)118
Dialogue: 0,0:16:14.28,0:16:21.40,Chinese,,0,0,0,,它会减少栈指针，即从(0x)120和十六进制中减去8会得到(0x)118
Dialogue: 0,0:16:22.08,0:16:31.32,English,,0,0,0,,And it would write the address of the instruction following the call onto the top of the stack
Dialogue: 0,0:16:22.08,0:16:31.32,Chinese,,0,0,0,,它会将调用后的指令地址写入堆栈顶部
Dialogue: 0,0:16:32.16,0:16:36.68,English,,0,0,0,,And it's important that it does it the one following the call to fit
Dialogue: 0,0:16:32.16,0:16:36.68,Chinese,,0,0,0,,并且重要的是，它是按照适合的要求进行的
Dialogue: 0,0:16:36.94,0:16:42.04,English,,0,0,0,,That's instruction I'm going to return a use for my return address
Dialogue: 0,0:16:36.94,0:16:42.04,Chinese,,0,0,0,,这是我将要返回用于返回地址的指令
Dialogue: 0,0:16:42.60,0:16:46.32,English,,0,0,0,,And I want to resume execution in this function
Dialogue: 0,0:16:42.60,0:16:46.32,Chinese,,0,0,0,,我想继续执行这个函数
Dialogue: 0,0:16:46.90,0:16:51.82,English,,0,0,0,,At the instruction after the call not the call itself otherwise you'd have an infinite loop
Dialogue: 0,0:16:46.90,0:16:51.82,Chinese,,0,0,0,,在调用指令之后而不是其本身，否则会导致无限循环
Dialogue: 0,0:16:54.52,0:17:06.64,English,,0,0,0,,And it also this call instruction also embedded in the encoding of the instruction is the destination address of it
Dialogue: 0,0:16:54.52,0:17:06.64,Chinese,,0,0,0,,在call指令的编码中也有指令的目标地址
Dialogue: 0,0:17:07.88,0:17:12.62,English,,0,0,0,,And which happens to be the starting address of this particular function
Dialogue: 0,0:17:07.88,0:17:12.62,Chinese,,0,0,0,,该地址恰好是函数的起始地址
Dialogue: 0,0:17:13.02,0:17:16.44,English,,0,0,0,,So the program counter will be set to that value
Dialogue: 0,0:17:13.02,0:17:16.44,Chinese,,0,0,0,,因此程序计数器将设置为该值
Dialogue: 0,0:17:16.54,0:17:22.76,English,,0,0,0,,And now the processor starts just executing along these instructions
Dialogue: 0,0:17:16.54,0:17:22.76,Chinese,,0,0,0,,现在处理器开始执行这些指令
Dialogue: 0,0:17:22.78,0:17:28.28,English,,0,0,0,,So it did a combination of a jump and a push and that's why the question was raised earlier
Dialogue: 0,0:17:22.78,0:17:28.28,Chinese,,0,0,0,,所以它做了一个jump和push的组合，这就是为什么之前提出的问题
Dialogue: 0,0:17:28.56,0:17:34.32,English,,0,0,0,,Is a push instruction could you assemble that out of existing instructions
Dialogue: 0,0:17:28.56,0:17:34.32,Chinese,,0,0,0,,push指令是否可以根据现有指令进行组装
Dialogue: 0,0:17:34.32,0:17:36.70,English,,0,0,0,,The answer is yes for push but not for call
Dialogue: 0,0:17:34.32,0:17:36.70,Chinese,,0,0,0,,对于push而言是这样，而call指令就不是了
Dialogue: 0,0:17:36.96,0:17:38.04,English,,0,0,0,,Question back there
Dialogue: 0,0:17:36.96,0:17:38.04,Chinese,,0,0,0,,问题回到那里
Dialogue: 0,0:17:38.42,0:17:47.18,English,,0,0,0,,- before you actually go to the function in like multstore you would let me address some mult2 into %rip?
Dialogue: 0,0:17:38.42,0:17:47.18,Chinese,,0,0,0,, - 在你真正进入multstore之前，会将mult2的地址存入%rip吗？
Dialogue: 0,0:17:47.24,0:17:52.30,English,,0,0,0,,No no it did that %rip you never explicitly
Dialogue: 0,0:17:47.24,0:17:52.30,Chinese,,0,0,0,,不，你不会明确地看到%rip做了什么
Dialogue: 0,0:17:52.54,0:17:55.22,English,,0,0,0,,There aren't instructions that manipulate that directly
Dialogue: 0,0:17:52.54,0:17:55.22,Chinese,,0,0,0,,没有直接操纵它的指令
Dialogue: 0,0:17:55.50,0:17:58.28,English,,0,0,0,,It's implicitly part of the call instruction
Dialogue: 0,0:17:55.50,0:17:58.28,Chinese,,0,0,0,,它是call指令隐含的一部分
Dialogue: 0,0:17:59.14,0:18:00.82,English,,0,0,0,,The call instruction will take
Dialogue: 0,0:17:59.14,0:18:00.82,Chinese,,0,0,0,,这都是call指令会做的
Dialogue: 0,0:18:01.46,0:18:04.40,English,,0,0,0,,I don't have the actual encoding
Dialogue: 0,0:18:01.46,0:18:04.40,Chinese,,0,0,0,,我没有实际的编码
Dialogue: 0,0:18:04.40,0:18:11.72,English,,0,0,0,,But embedded in this call instruction you see that it's five bytes long, I don't show you the byte coding
Dialogue: 0,0:18:04.40,0:18:11.72,Chinese,,0,0,0,,但是嵌入在这个调用指令中，你看到它长达五个字节，我没有向你展示字节编码
Dialogue: 0,0:18:12.14,0:18:14.30,English,,0,0,0,,But embedded in it is the target address
Dialogue: 0,0:18:12.14,0:18:14.30,Chinese,,0,0,0,,但嵌入其中的是目标地址
Dialogue: 0,0:18:14.96,0:18:20.00,English,,0,0,0,,And so it will take that address and use it for the new value of the program counter
Dialogue: 0,0:18:14.96,0:18:20.00,Chinese,,0,0,0,,因此它将采用该地址并将其作为程序计数器的新值
Dialogue: 0,0:18:21.38,0:18:32.24,English,,0,0,0,,So the call does both the pushing of the old the return pointer and setting the program counter to the new target for it
Dialogue: 0,0:18:21.38,0:18:32.24,Chinese,,0,0,0,,call指令同时push原本的返回值并为程序计数器设置新目标
Dialogue: 0,0:18:33.06,0:18:34.74,English,,0,0,0,,So it does both of those things
Dialogue: 0,0:18:33.06,0:18:34.74,Chinese,,0,0,0,,所以它做了这两件事
Dialogue: 0,0:18:38.16,0:18:38.96,English,,0,0,0,,Question
Dialogue: 0,0:18:38.16,0:18:38.96,Chinese,,0,0,0,,题
Dialogue: 0,0:18:39.72,0:18:46.06,English,,0,0,0,,Is there any ways affecting program counter using ...
Dialogue: 0,0:18:39.72,0:18:46.06,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:18:46.14,0:18:49.62,English,,0,0,0,,I don't think so,with either call or return
Dialogue: 0,0:18:46.14,0:18:49.62,Chinese,,0,0,0,,无论是call还是return，我都不这么认为
Dialogue: 0,0:18:52.34,0:18:57.84,English,,0,0,0,,If so it would be really obscure,no I don't think so
Dialogue: 0,0:18:52.34,0:18:57.84,Chinese,,0,0,0,,如果是这样，那将是非常模糊的，不，我不这么认为
Dialogue: 0,0:18:58.68,0:19:06.46,English,,0,0,0,,No so call and return are the there might be some weird system instructions that let you do that but not in you'd see in any normal program
Dialogue: 0,0:18:58.68,0:19:06.46,Chinese,,0,0,0,,call和return是这样，可能有一些奇怪的系统指令让你这样做，但不是你在任何正常程序中看到的
Dialogue: 0,0:19:08.60,0:19:10.80,English,,0,0,0,,Other questions you've good questions
Dialogue: 0,0:19:08.60,0:19:10.80,Chinese,,0,0,0,,其他问题？你们提出了很好的问题
Dialogue: 0,0:19:11.04,0:19:11.82,English,,0,0,0,,So
Dialogue: 0,0:19:11.04,0:19:11.82,Chinese,,0,0,0,,所以
Dialogue: 0,0:19:15.66,0:19:18.64,English,,0,0,0,,Okay so that shows you the control how the call works
Dialogue: 0,0:19:15.66,0:19:18.64,Chinese,,0,0,0,,好的，这样就讲了控制中call是如何工作的
Dialogue: 0,0:19:20.84,0:19:25.04,English,,0,0,0,,And then so now imagine this mult2 chugs along
Dialogue: 0,0:19:20.84,0:19:25.04,Chinese,,0,0,0,,然后现在想象这个mult2运行
Dialogue: 0,0:19:25.72,0:19:29.30,English,,0,0,0,,And it hits its return point and it hits this ret instruction
Dialogue: 0,0:19:25.72,0:19:29.30,Chinese,,0,0,0,,它到达返回点并且到达这个ret指令
Dialogue: 0,0:19:29.44,0:19:32.54,English,,0,0,0,,By the way again retq and rep the same instruction
Dialogue: 0,0:19:29.44,0:19:32.54,Chinese,,0,0,0,,顺便说一下retq和rep是同样的指令
Dialogue: 0,0:19:33.48,0:19:40.48,English,,0,0,0,,And ret will ts purpose is to sort of reverse the effect of a call
Dialogue: 0,0:19:33.48,0:19:40.48,Chinese,,0,0,0,,ret的目的是逆转call的效果
Dialogue: 0,0:19:41.08,0:19:48.46,English,,0,0,0,,It assumes that the top of the stack has an address that you want to jump to
Dialogue: 0,0:19:41.08,0:19:48.46,Chinese,,0,0,0,,它假定栈顶部有一个你想要跳转的地址
Dialogue: 0,0:19:49.54,0:19:52.60,English,,0,0,0,,So it will pop that address off the stack
Dialogue: 0,0:19:49.54,0:19:52.60,Chinese,,0,0,0,,所以它会从栈中pop出该地址
Dialogue: 0,0:19:52.82,0:19:54.78,English,,0,0,0,,Meaning it will increment the stack pointer
Dialogue: 0,0:19:52.82,0:19:54.78,Chinese,,0,0,0,,这意味着它将增加栈指针
Dialogue: 0,0:19:54.96,0:19:58.50,English,,0,0,0,,Like I said the value doesn't really disappear from the memory
Dialogue: 0,0:19:54.96,0:19:58.50,Chinese,,0,0,0,,就像我说的那样，值并没有真正从内存中消失
Dialogue: 0,0:19:58.50,0:20:01.22,English,,0,0,0,,Just is no consider part of the stack
Dialogue: 0,0:19:58.50,0:20:01.22,Chinese,,0,0,0,,只是不被认为是栈的一部分
Dialogue: 0,0:20:02.00,0:20:06.58,English,,0,0,0,,And then it will set the program counter to what it just popped off the stack
Dialogue: 0,0:20:02.00,0:20:06.58,Chinese,,0,0,0,,然后它会将程序计数器设置为刚从堆栈中弹出的地址
Dialogue: 0,0:20:07.72,0:20:12.34,English,,0,0,0,,And that will cause the program to resume back to where it came from
Dialogue: 0,0:20:07.72,0:20:12.34,Chinese,,0,0,0,,这将导致程序回到原来的位置继续执行
Dialogue: 0,0:20:12.88,0:20:18.92,English,,0,0,0,,So you see that sort of clever idea of pushing the address of the next instruction
Dialogue: 0,0:20:12.88,0:20:18.92,Chinese,,0,0,0,,所以你看到了push下一条指令地址的这种聪明的想法
Dialogue: 0,0:20:18.92,0:20:23.82,English,,0,0,0,,So when the return comes it will get it to the point where it should resume execution
Dialogue: 0,0:20:18.92,0:20:23.82,Chinese,,0,0,0,,因此返回时它将达到应该恢复执行的地方
Dialogue: 0,0:20:27.40,0:20:29.04,English,,0,0,0,,Okay so that's passing control
Dialogue: 0,0:20:27.40,0:20:29.04,Chinese,,0,0,0,,好的，这就是传递控制
Dialogue: 0,0:20:29.10,0:20:33.76,English,,0,0,0,,It's pretty simple all these things by the way is just the nature machine code
Dialogue: 0,0:20:29.10,0:20:33.76,Chinese,,0,0,0,,所有这些事情都非常简单，顺便说一句就是自然机器代码
Dialogue: 0,0:20:34.12,0:20:36.18,English,,0,0,0,,Every single part of it is pretty simple
Dialogue: 0,0:20:34.12,0:20:36.18,Chinese,,0,0,0,,它的每一部分都非常简单
Dialogue: 0,0:20:36.18,0:20:42.54,English,,0,0,0,,Because it's designed to be executed by the original hardware is fairly simple
Dialogue: 0,0:20:36.18,0:20:42.54,Chinese,,0,0,0,,因为它被设计为由原始硬件执行，所以相当简单
Dialogue: 0,0:20:43.00,0:20:46.80,English,,0,0,0,,It's not any more but it's really the basic ideas are
Dialogue: 0,0:20:43.00,0:20:46.80,Chinese,,0,0,0,,这没有太大的难度，但这的确就是最基本的思想
Dialogue: 0,0:20:47.40,0:20:56.32,English,,0,0,0,,And that we use kind of combinations of instructions to build up all the layers associated with operations like procedure call and return
Dialogue: 0,0:20:47.40,0:20:56.32,Chinese,,0,0,0,,我们使用各种指令组合来构建所有与过程调用和返回等操作相关联的部分
Dialogue: 0,0:20:57.14,0:20:58.74,English,,0,0,0,,Ok so passing data
Dialogue: 0,0:20:57.14,0:20:58.74,Chinese,,0,0,0,,好，下面是传递数据
Dialogue: 0,0:20:59.36,0:21:03.62,English,,0,0,0,,Now we've already seen a few small examples of passing data
Dialogue: 0,0:20:59.36,0:21:03.62,Chinese,,0,0,0,,现在我们已经看到了一些传递数据的小例子
Dialogue: 0,0:21:04.92,0:21:10.53,English,,0,0,0,,We've seen a couple registers that get used when you're passing arguments to a function
Dialogue: 0,0:21:04.92,0:21:10.53,Chinese,,0,0,0,,我们已经看到了一些传参时使用的寄存器
Dialogue: 0,0:21:11.04,0:21:15.82,English,,0,0,0,,And we've seen the register %rax getting used to return values from a function
Dialogue: 0,0:21:11.04,0:21:15.82,Chinese,,0,0,0,,我们已经看到寄存器％rax习惯于从函数返回值
Dialogue: 0,0:21:16.26,0:21:18.30,English,,0,0,0,,And so those that's the basic idea
Dialogue: 0,0:21:16.26,0:21:18.30,Chinese,,0,0,0,,所以那些是基本的想法
Dialogue: 0,0:21:19.38,0:21:22.10,English,,0,0,0,,And again this is all built into this ABI
Dialogue: 0,0:21:19.38,0:21:22.10,Chinese,,0,0,0,,而这一切都在这个ABI中
Dialogue: 0,0:21:23.06,0:21:26.94,English,,0,0,0,,You know defined as the set of conventions not particularly part of the hardware
Dialogue: 0,0:21:23.06,0:21:26.94,Chinese,,0,0,0,,你知道定义为一组约定而不是硬件的一部分
Dialogue: 0,0:21:27.70,0:21:36.98,English,,0,0,0,,So in particular the rule is that the first six arguments get passed within these particular registers
Dialogue: 0,0:21:27.70,0:21:36.98,Chinese,,0,0,0,,因此特别地，规则是前六个参数通过这些特定的寄存器传递
Dialogue: 0,0:21:38.26,0:21:45.36,English,,0,0,0,,And you just have to memorize the order of them or have a table handy to look at
Dialogue: 0,0:21:38.26,0:21:45.36,Chinese,,0,0,0,,而你只需要记住它们的顺序或者有一个方便的表格来查看
Dialogue: 0,0:21:45.36,0:21:48.60,English,,0,0,0,,Or something like that because there's no particular logic to it
Dialogue: 0,0:21:45.36,0:21:48.60,Chinese,,0,0,0,,或类似的东西，因为它没有特定的逻辑
Dialogue: 0,0:21:52.38,0:21:57.34,English,,0,0,0,,And the return value is returned in register %rax
Dialogue: 0,0:21:52.38,0:21:57.34,Chinese,,0,0,0,,返回值在寄存器％rax中返回
Dialogue: 0,0:21:57.48,0:22:02.94,English,,0,0,0,,And by the way this is all for arguments that are either integers or pointers
Dialogue: 0,0:21:57.48,0:22:02.94,Chinese,,0,0,0,,顺便说一下，这些参数都是整数或指针
Dialogue: 0,0:22:03.40,0:22:08.94,English,,0,0,0,,Well I think I've got a little bit on float point those are passed in a separate set of registers
Dialogue: 0,0:22:03.40,0:22:08.94,Chinese,,0,0,0,,好吧，我想我有讲了一点浮点类型，它们是在一组单独的寄存器中传递的
Dialogue: 0,0:22:09.00,0:22:14.08,English,,0,0,0,,So these are just for assumed now we just are dealing with integer data pointer data
Dialogue: 0,0:22:09.00,0:22:14.08,Chinese,,0,0,0,,所以假设现在我们只处理整数数据和指针数据
Dialogue: 0,0:22:15.26,0:22:19.88,English,,0,0,0,,And then you ask well what happens if you have more than 6 arguments to a function
Dialogue: 0,0:22:15.26,0:22:19.88,Chinese,,0,0,0,,然后你会问，如果你有一个函数超过6个参数会发生什么
Dialogue: 0,0:22:19.88,0:22:22.12,English,,0,0,0,,Which isn't very common but it happens
Dialogue: 0,0:22:19.88,0:22:22.12,Chinese,,0,0,0,,这不是很常见，但它发生了
Dialogue: 0,0:22:22.60,0:22:26.20,English,,0,0,0,,Well the rule on that is those get put in memory on the stack
Dialogue: 0,0:22:22.60,0:22:26.20,Chinese,,0,0,0,,那么规则是那些参数被放入栈内存
Dialogue: 0,0:22:26.24,0:22:28.98,English,,0,0,0,,And I'll show straight what I mean by that
Dialogue: 0,0:22:26.24,0:22:28.98,Chinese,,0,0,0,,我会直截了当地表明我的意思
Dialogue: 0,0:22:29.56,0:22:31.48,English,,0,0,0,,So they're passed to the function
Dialogue: 0,0:22:29.56,0:22:31.48,Chinese,,0,0,0,,所以他们被传递给了这个函数
Dialogue: 0,0:22:31.92,0:22:34.80,English,,0,0,0,,And then the function has to retrieve those values off the stack
Dialogue: 0,0:22:31.92,0:22:34.80,Chinese,,0,0,0,,然后该函数必须从堆栈中检索这些值
Dialogue: 0,0:22:36.92,0:22:41.74,English,,0,0,0,,Back in the bad old days of IA-32 by the way all arguments got passed on the stack
Dialogue: 0,0:22:36.92,0:22:41.74,Chinese,,0,0,0,,回到IA-32过去的糟糕时期，所有参数都在栈中传递
Dialogue: 0,0:22:42.14,0:22:46.18,English,,0,0,0,,But now for the most part you pass arguments and registers
Dialogue: 0,0:22:42.14,0:22:46.18,Chinese,,0,0,0,,但现在大多数情况下你传递参数和寄存器
Dialogue: 0,0:22:46.94,0:22:51.38,English,,0,0,0,,And the reason for that is register access is way faster than memory access
Dialogue: 0,0:22:46.94,0:22:51.38,Chinese,,0,0,0,,原因是寄存器访问比内存访问更快
Dialogue: 0,0:22:52.84,0:22:56.72,English,,0,0,0,,Okay so here is a kind of a messy bunch of code
Dialogue: 0,0:22:52.84,0:22:56.72,Chinese,,0,0,0,,好的，所以这里是一堆乱七八糟的代码
Dialogue: 0,0:22:56.72,0:23:00.98,English,,0,0,0,,But just to show you how they show up all the time
Dialogue: 0,0:22:56.72,0:23:00.98,Chinese,,0,0,0,,但只是为了向你展示它们如何工作
Dialogue: 0,0:23:03.00,0:23:07.17,English,,0,0,0,,In the function multstore as three arguments x,y and *dest
Dialogue: 0,0:23:03.00,0:23:07.17,Chinese,,0,0,0,,在函数multstore中有三个参数x，y和* dest
Dialogue: 0,0:23:08.00,0:23:09.98,English,,0,0,0,,And you can just see within this code
Dialogue: 0,0:23:08.00,0:23:09.98,Chinese,,0,0,0,,你可以在这段代码中看到
Dialogue: 0,0:23:10.52,0:23:15.24,English,,0,0,0,,That it's making use of of registers like %rdi
Dialogue: 0,0:23:10.52,0:23:15.24,Chinese,,0,0,0,,它正在利用像％rdi这样的寄存器
Dialogue: 0,0:23:16.10,0:23:19.26,English,,0,0,0,,And doesn't show where
Dialogue: 0,0:23:16.10,0:23:19.26,Chinese,,0,0,0,,并没有显示在哪里
Dialogue: 0,0:23:19.50,0:23:23.32,English,,0,0,0,,And in other places like mult2 as two arguments
Dialogue: 0,0:23:19.50,0:23:23.32,Chinese,,0,0,0,,而在其他地方，如mult2有两个参数
Dialogue: 0,0:23:23.90,0:23:28.00,English,,0,0,0,,And you can see how it's making use of %rdi and %rsi in code
Dialogue: 0,0:23:23.90,0:23:28.00,Chinese,,0,0,0,,你可以看到它是如何在代码中使用％rdi和％rsi的
Dialogue: 0,0:23:28.08,0:23:39.36,English,,0,0,0,,So basically the code is generated under the assumptions that whatever arguments is being passed to it will be passed in that particular set of registers in the particular order they're listed
Dialogue: 0,0:23:28.08,0:23:39.36,Chinese,,0,0,0,,基本上代码能运行是基于这样的假设：无论什么参数都按列出的顺序被传递给这一系列寄存器
Dialogue: 0,0:23:39.70,0:23:42.68,English,,0,0,0,,And the code is sort of makes those assumptions
Dialogue: 0,0:23:39.70,0:23:42.68,Chinese,,0,0,0,,并且代码做出这些假设
Dialogue: 0,0:23:42.96,0:23:48.50,English,,0,0,0,,And then similarly when you have a return value from the function
Dialogue: 0,0:23:42.96,0:23:48.50,Chinese,,0,0,0,,然后类似地，当你有一个函数的返回值
Dialogue: 0,0:23:51.20,0:23:53.88,English,,0,0,0,,Let's see multstore does not have a return value
Dialogue: 0,0:23:51.20,0:23:53.88,Chinese,,0,0,0,,让我们看看multstore没有返回值
Dialogue: 0,0:23:54.30,0:23:56.88,English,,0,0,0,,But of mult2 does
Dialogue: 0,0:23:54.30,0:23:56.88,Chinese,,0,0,0,,但是mult2确实如此
Dialogue: 0,0:23:58.02,0:24:01.98,English,,0,0,0,,And the way it does is it deposits the value into %rax
Dialogue: 0,0:23:58.02,0:24:01.98,Chinese,,0,0,0,,它的作用方式是将值存入％rax
Dialogue: 0,0:24:02.78,0:24:08.96,English,,0,0,0,,And then when the return from %rax occurs to multstore
Dialogue: 0,0:24:02.78,0:24:08.96,Chinese,,0,0,0,,然后当从％rax返回到mulstore发生时
Dialogue: 0,0:24:09.54,0:24:12.96,English,,0,0,0,,You see that..it assumes
Dialogue: 0,0:24:09.54,0:24:12.96,Chinese,,0,0,0,,你看，那是假设的
Dialogue: 0,0:24:13.58,0:24:22.64,English,,0,0,0,,Now that the multstore code can assume that register %rax holds  the return value
Dialogue: 0,0:24:13.58,0:24:22.64,Chinese,,0,0,0,,现在multstore代码可以假设寄存器％rax保存返回值
Dialogue: 0,0:24:22.90,0:24:26.02,English,,0,0,0,,And it can store it in its destination register
Dialogue: 0,0:24:22.90,0:24:26.02,Chinese,,0,0,0,,它可以将其存储在目标寄存器中
Dialogue: 0,0:24:26.56,0:24:29.48,English,,0,0,0,,And we'll look in a minute why %rbx gets used here
Dialogue: 0,0:24:26.56,0:24:29.48,Chinese,,0,0,0,,我们将在一分钟内了解为什么在这里使用％rbx
Dialogue: 0,0:24:30.66,0:24:32.82,English,,0,0,0,,We'll cover that in just a little waiter
Dialogue: 0,0:24:30.66,0:24:32.82,Chinese,,0,0,0,,我们一会儿就会提到
Dialogue: 0,0:24:33.48,0:24:38.88,English,,0,0,0,,But that's the point that as long as everyone sticks to this common interface standard
Dialogue: 0,0:24:33.48,0:24:38.88,Chinese,,0,0,0,,但是重点在于，只要每个人都坚持这种通用接口标准
Dialogue: 0,0:24:39.30,0:24:43.78,English,,0,0,0,,Then you can even use different compilers to compile code
Dialogue: 0,0:24:39.30,0:24:43.78,Chinese,,0,0,0,,然后你甚至可以使用不同的编译器来编译代码
Dialogue: 0,0:24:44.06,0:24:50.88,English,,0,0,0,,And have them be able to cooperate with each other in terms of passing arguments returning data
Dialogue: 0,0:24:44.06,0:24:50.88,Chinese,,0,0,0,,并且让他们能够在传参与返回数据方面相互合作
Dialogue: 0,0:24:51.58,0:24:54.52,English,,0,0,0,,And that's the reason why you want that convention
Dialogue: 0,0:24:51.58,0:24:54.52,Chinese,,0,0,0,,这就是你想要这个惯例的原因
Dialogue: 0,0:24:54.54,0:24:55.08,English,,0,0,0,,Yes
Dialogue: 0,0:24:54.54,0:24:55.08,Chinese,,0,0,0,,是
Dialogue: 0,0:24:55.86,0:24:59.12,English,,0,0,0,,[student speaking]
Dialogue: 0,0:24:55.86,0:24:59.12,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:24:59.18,0:25:03.74,English,,0,0,0,,8 bytes because the well first of all for call and return
Dialogue: 0,0:24:59.18,0:25:03.74,Chinese,,0,0,0,,8个字节，首先对于call和return
Dialogue: 0,0:25:04.12,0:25:09.10,English,,0,0,0,,It's a 64-bit machine so all addresses are 64 bits or 8 bytes
Dialogue: 0,0:25:04.12,0:25:09.10,Chinese,,0,0,0,,它是一台64位机器，因此所有地址都是64位或8字节
Dialogue: 0,0:25:09.80,0:25:14.72,English,,0,0,0,,But also even the push and pop instruction only work on 8 byte values
Dialogue: 0,0:25:09.80,0:25:14.72,Chinese,,0,0,0,,但是，即使push于pop指令也仅适用于8字节值
Dialogue: 0,0:25:15.44,0:25:20.54,English,,0,0,0,,If you said pushl ,if you tried to write that in x in 64-bit code
Dialogue: 0,0:25:15.44,0:25:20.54,Chinese,,0,0,0,,如果你说pushl，如果你试图在64位代码中写入x
Dialogue: 0,0:25:20.54,0:25:22.37,English,,0,0,0,,It would come back with a syntax error
Dialogue: 0,0:25:20.54,0:25:22.37,Chinese,,0,0,0,,它会返回语法错误
Dialogue: 0,0:25:23.06,0:25:24.88,English,,0,0,0,,If you add it in this somewhere
Dialogue: 0,0:25:23.06,0:25:24.88,Chinese,,0,0,0,,如果你把它添加到某个地方
Dialogue: 0,0:25:28.82,0:25:33.46,English,,0,0,0,,So that,and that's different IA-32 there'd be four byte values
Dialogue: 0,0:25:28.82,0:25:33.46,Chinese,,0,0,0,,所以，那是不同的IA-32，有四个字节值
Dialogue: 0,0:25:37.00,0:25:43.56,English,,0,0,0,,Okay so like I said you've sort of seen that implicitly in some of the code you've already been looking at
Dialogue: 0,0:25:37.00,0:25:43.56,Chinese,,0,0,0,,好的，就像我说你已经在你已经看过的一些代码中隐含地看到的那样
Dialogue: 0,0:25:43.56,0:25:45.56,English,,0,0,0,,And it's pretty straightforward
Dialogue: 0,0:25:43.56,0:25:45.56,Chinese,,0,0,0,,而且非常简单
Dialogue: 0,0:25:46.00,0:25:50.56,English,,0,0,0,,To get an example that shows passing arguments
Dialogue: 0,0:25:46.00,0:25:50.56,Chinese,,0,0,0,,为了获取一个显示传递参数的示例
Dialogue: 0,0:25:50.56,0:25:54.80,English,,0,0,0,,You have a function with at least 7 arguments which is pretty messy to do
Dialogue: 0,0:25:50.56,0:25:54.80,Chinese,,0,0,0,,需要一个至少有7个参数的函数，这是非常混乱的
Dialogue: 0,0:25:54.80,0:25:57.08,English,,0,0,0,,So I won't do it but there's examples in the book
Dialogue: 0,0:25:54.80,0:25:57.08,Chinese,,0,0,0,,所以我不会这样做，但书中有例子
Dialogue: 0,0:25:59.74,0:26:02.54,English,,0,0,0,,But now and we'll sort of pick it up
Dialogue: 0,0:25:59.74,0:26:02.54,Chinese,,0,0,0,,但是现在我们会接受它
Dialogue: 0,0:26:02.54,0:26:05.70,English,,0,0,0,,I'll show you,also in this later part
Dialogue: 0,0:26:02.54,0:26:05.70,Chinese,,0,0,0,,我也会是在后面的部分告诉你
Dialogue: 0,0:26:06.84,0:26:11.00,English,,0,0,0,,And now the third part of it is again
Dialogue: 0,0:26:06.84,0:26:11.00,Chinese,,0,0,0,,现在它的第三部分又来了
Dialogue: 0,0:26:11.00,0:26:14.08,English,,0,0,0,,What if there's some local data that we need to make use of
Dialogue: 0,0:26:11.00,0:26:14.08,Chinese,,0,0,0,,如果有一些我们需要使用的本地数据怎么办？
Dialogue: 0,0:26:14.76,0:26:22.84,English,,0,0,0,,And so to get that idea across I have bring another concept which is called the stack frame
Dialogue: 0,0:26:14.76,0:26:22.84,Chinese,,0,0,0,,因此，为了使你们理解，我引入了另一个叫做栈帧的概念
Dialogue: 0,0:26:23.58,0:26:29.88,English,,0,0,0,,And so this is a particular allocation pattern that's used in memory and as I mentioned earlier
Dialogue: 0,0:26:23.58,0:26:29.88,Chinese,,0,0,0,,所以这是一个用在内存中的特别分配模式，正如之前我提到的
Dialogue: 0,0:26:30.34,0:26:40.94,English,,0,0,0,,One of the features of calling and returning is you can imagine when you have a nested series of calls to a function
Dialogue: 0,0:26:30.34,0:26:40.94,Chinese,,0,0,0,,调用和返回的功能之一是当你对函数进行嵌套系列调用时
Dialogue: 0,0:26:41.64,0:26:44.02,English,,0,0,0,,When a particular function is executing
Dialogue: 0,0:26:41.64,0:26:44.02,Chinese,,0,0,0,,执行特定功能时
Dialogue: 0,0:26:46.32,0:26:54.20,English,,0,0,0,,It only needs to reference the data within that function or values that have been passed to it
Dialogue: 0,0:26:46.32,0:26:54.20,Chinese,,0,0,0,,它只需要引用该函数中的数据或已传递给它的值
Dialogue: 0,0:26:54.90,0:26:59.22,English,,0,0,0,,Some which might be pointers and therefore pointing to other locations in memory
Dialogue: 0,0:26:54.90,0:26:59.22,Chinese,,0,0,0,,一些可能是指针，因此指向内存中的其他位置
Dialogue: 0,0:26:59.24,0:27:11.62,English,,0,0,0,,But the point is sort of the rest of the functions in your code however many there are are sort of frozen at that moment really there's only one function executing at any given time
Dialogue: 0,0:26:59.24,0:27:11.62,Chinese,,0,0,0,, 但关键是代码中其他函数，无论有多少，在那个时刻都被冻结了，在任何给定的时间只有一个函数在运行
Dialogue: 0,0:27:12.08,0:27:17.20,English,,0,0,0,,I'm assuming a sort of what you'd call single threaded model here
Dialogue: 0,0:27:12.08,0:27:17.20,Chinese,,0,0,0,,我假设你在这里称之为单线程模型
Dialogue: 0,0:27:18.20,0:27:26.12,English,,0,0,0,,And so we can just allocate on this stack whatever space is required for this particular function
Dialogue: 0,0:27:18.20,0:27:26.12,Chinese,,0,0,0,,所以我们可以在这个栈上分配函数需要的空间，无论多少
Dialogue: 0,0:27:26.82,0:27:29.04,English,,0,0,0,,And then when we return from that function
Dialogue: 0,0:27:26.82,0:27:29.04,Chinese,,0,0,0,,然后当我们从那个函数返回时
Dialogue: 0,0:27:29.46,0:27:35.70,English,,0,0,0,,We shouldn't if it's correctly written need any of the information associated with that function
Dialogue: 0,0:27:29.46,0:27:35.70,Chinese,,0,0,0,,如果正确编写，我们不需要与该函数相关的任何信息
Dialogue: 0,0:27:35.70,0:27:37.50,English,,0,0,0,,It can just sort of disappear forever
Dialogue: 0,0:27:35.70,0:27:37.50,Chinese,,0,0,0,,它可以永远消失
Dialogue: 0,0:27:37.82,0:27:39.78,English,,0,0,0,,And that's why this idea of a stack
Dialogue: 0,0:27:37.82,0:27:39.78,Chinese,,0,0,0,,这就是为什么我们用栈的思想
Dialogue: 0,0:27:40.26,0:27:45.58,English,,0,0,0,,You allocate something if you make more calls you keep allocating more stuff
Dialogue: 0,0:27:40.26,0:27:45.58,Chinese,,0,0,0,,如果你调用函数就会不停地分配空间
Dialogue: 0,0:27:45.72,0:27:50.60,English,,0,0,0,,But as they return you kind of back out of the stack and and free things up
Dialogue: 0,0:27:45.72,0:27:50.60,Chinese,,0,0,0,,但当它们返回的时候你会推出栈并释放空间
Dialogue: 0,0:27:51.36,0:27:54.16,English,,0,0,0,,So the stack discipline is exactly the right
Dialogue: 0,0:27:51.36,0:27:54.16,Chinese,,0,0,0,,所以堆栈规则是正确的
Dialogue: 0,0:27:54.84,0:27:58.06,English,,0,0,0,,It matches well this whole idea of procedure call and return
Dialogue: 0,0:27:54.84,0:27:58.06,Chinese,,0,0,0,,它吻合过程调用与返回的思想
Dialogue: 0,0:27:58.70,0:28:04.06,English,,0,0,0,,So each block we use for a particular call then is called the stack frame
Dialogue: 0,0:27:58.70,0:28:04.06,Chinese,,0,0,0,,因此，我们用于特定call的每个块称为栈帧
Dialogue: 0,0:28:07.44,0:28:17.48,English,,0,0,0,,And to be sort of more technical we'll say that it's a frame for a particular instance of a procedure a particular call to a procedure
Dialogue: 0,0:28:07.44,0:28:17.48,Chinese,,0,0,0,, 更技术性地说，它是特定过程调用的框架
Dialogue: 0,0:28:19.16,0:28:24.28,English,,0,0,0,,So just imagine we had a set of functions one called "yoo"
Dialogue: 0,0:28:19.16,0:28:24.28,Chinese,,0,0,0,,所以想象一下我们有一组叫做"yoo"的函数
Dialogue: 0,0:28:24.86,0:28:26.72,English,,0,0,0,,Which calls a function called "who"
Dialogue: 0,0:28:24.86,0:28:26.72,Chinese,,0,0,0,,调用了"who"函数
Dialogue: 0,0:28:27.30,0:28:32.42,English,,0,0,0,,And "who" has multiple calls to another function called "amI"
Dialogue: 0,0:28:27.30,0:28:32.42,Chinese,,0,0,0,,"who"多次调用了函数"amI"
Dialogue: 0,0:28:32.90,0:28:36.40,English,,0,0,0,,And "amI" is itself is recursive it calls itself
Dialogue: 0,0:28:32.90,0:28:36.40,Chinese,,0,0,0,,而"amI"本身就是递归调用自身的
Dialogue: 0,0:28:37.44,0:28:42.86,English,,0,0,0,,And so an imagine we had a chain of calls
Dialogue: 0,0:28:37.44,0:28:42.86,Chinese,,0,0,0,,所以想象一下，我们有一连串的调用
Dialogue: 0,0:28:42.98,0:28:46.04,English,,0,0,0,,Where "yoo" calls "who" calls "amI"
Dialogue: 0,0:28:42.98,0:28:46.04,Chinese,,0,0,0,,"yoo"调用"who"，"who"调用"amI"
Dialogue: 0,0:28:46.44,0:28:48.82,English,,0,0,0,,Which calls itself recursively twice
Dialogue: 0,0:28:46.44,0:28:48.82,Chinese,,0,0,0,,它递归调用自己两次
Dialogue: 0,0:28:49.56,0:28:54.00,English,,0,0,0,,And then we'll exit out of "amI" and get back to "who"
Dialogue: 0,0:28:49.56,0:28:54.00,Chinese,,0,0,0,,然后我们退出"amI"并回到"who"
Dialogue: 0,0:28:54.34,0:28:57.06,English,,0,0,0,,And then "who" will hit it second call to "amI"
Dialogue: 0,0:28:54.34,0:28:57.06,Chinese,,0,0,0,,然后"who"将第二次调用"amI"
Dialogue: 0,0:28:57.28,0:29:00.36,English,,0,0,0,,Which won't go any further and that will be it
Dialogue: 0,0:28:57.28,0:29:00.36,Chinese,,0,0,0,,不会再进一步​​了，那就是它
Dialogue: 0,0:29:00.54,0:29:07.16,English,,0,0,0,,So this picture here shows this whole history of all these calls that get made
Dialogue: 0,0:29:00.54,0:29:07.16,Chinese,,0,0,0,,所以这张图片显示了所有这些调用的整个历史
Dialogue: 0,0:29:09.52,0:29:11.16,English,,0,0,0,,But in terms of the stack
Dialogue: 0,0:29:09.52,0:29:11.16,Chinese,,0,0,0,,但就栈而言
Dialogue: 0,0:29:14.42,0:29:20.52,English,,0,0,0,,All we need what will keep a frame for every sort of procedure that has been called
Dialogue: 0,0:29:14.42,0:29:20.52,Chinese,,0,0,0,,我们所需要的只是在栈中为每种被调用的过程保留一个框架
Dialogue: 0,0:29:20.52,0:29:25.26,English,,0,0,0,,But not yet returned on the stack
Dialogue: 0,0:29:20.52,0:29:25.26,Chinese,,0,0,0,,但还没有返回
Dialogue: 0,0:29:25.72,0:29:31.12,English,,0,0,0,,And in general this stack of is delimited by two pointers
Dialogue: 0,0:29:25.72,0:29:31.12,Chinese,,0,0,0,,通常这个堆栈由两个指针分隔
Dialogue: 0,0:29:31.12,0:29:33.74,English,,0,0,0,,One is the stack pointer which we're familiar with
Dialogue: 0,0:29:31.12,0:29:33.74,Chinese,,0,0,0,,一个是我们熟悉的堆栈指针
Dialogue: 0,0:29:34.30,0:29:40.04,English,,0,0,0,,And then there's another called the base pointer which register %rbp indicates
Dialogue: 0,0:29:34.30,0:29:40.04,Chinese,,0,0,0,,然后还有一个叫做基本指针的寄存器％rbp
Dialogue: 0,0:29:40.56,0:29:50.80,English,,0,0,0,,But one a feature of actually it's now become a feature of IA32 as well is that this is an optional pointer
Dialogue: 0,0:29:40.56,0:29:50.80,Chinese,,0,0,0,,但实际上它的一个特征（现在也成为IA32的一个特征）是这是一个可选指针
Dialogue: 0,0:29:51.68,0:29:56.46,English,,0,0,0,,And in particular the code that we'll see does not use a base pointer
Dialogue: 0,0:29:51.68,0:29:56.46,Chinese,,0,0,0,,特别地，我们将看到的代码不使用基指针
Dialogue: 0,0:29:56.80,0:29:59.56,English,,0,0,0,,Except in some very special cases
Dialogue: 0,0:29:56.80,0:29:59.56,Chinese,,0,0,0,,除了一些非常特殊的情况
Dialogue: 0,0:30:00.36,0:30:09.92,English,,0,0,0,,So this register doesn't really won't show up in your programs being used in a special way as a frame pointer
Dialogue: 0,0:30:00.36,0:30:09.92,Chinese,,0,0,0,,所以这个寄存器实际上不会出现在你的程序中以特殊方式用作帧指针
Dialogue: 0,0:30:10.34,0:30:13.20,English,,0,0,0,,It will be used instead just as a regular register
Dialogue: 0,0:30:10.34,0:30:13.20,Chinese,,0,0,0,,它将被用作常规寄存器
Dialogue: 0,0:30:14.48,0:30:17.94,English,,0,0,0,,So typically then the only thing you'll know about the stack pointer
Dialogue: 0,0:30:14.48,0:30:17.94,Chinese,,0,0,0,,所以通常你会知道关于栈指针的唯一事情
Dialogue: 0,0:30:17.94,0:30:22.78,English,,0,0,0,,You won't even be able to figure out where the frame is exactly
Dialogue: 0,0:30:17.94,0:30:22.78,Chinese,,0,0,0,,你甚至无法弄清楚框架的确切位置
Dialogue: 0,0:30:22.78,0:30:29.96,English,,0,0,0,,You'll just know that the top part of the stack is the top frame for the topmost function
Dialogue: 0,0:30:22.78,0:30:29.96,Chinese,,0,0,0,,你只知道栈的顶部是最顶层函数的顶部框架
Dialogue: 0,0:30:31.06,0:30:34.66,English,,0,0,0,,And this is all managed by the code itself
Dialogue: 0,0:30:31.06,0:30:34.66,Chinese,,0,0,0,,这一切都由代码本身管理
Dialogue: 0,0:30:37.04,0:30:42.30,English,,0,0,0,,And this is the same stack by the way in which you're pushing and popping addresses too
Dialogue: 0,0:30:37.04,0:30:42.30,Chinese,,0,0,0,,这同样是那个你pop和push地址的栈
Dialogue: 0,0:30:42.30,0:30:44.30,English,,0,0,0,,And they all kind of get mixed together
Dialogue: 0,0:30:42.30,0:30:44.30,Chinese,,0,0,0,,他们都混在了一起
Dialogue: 0,0:30:47.40,0:30:54.32,English,,0,0,0,,So we haven't actually seen any code up til now that makes you ask to do any explicit management of the stack
Dialogue: 0,0:30:47.40,0:30:54.32,Chinese,,0,0,0,,所以我们知道现在还没有看到任何代码要求你对栈进行任何显式管理
Dialogue: 0,0:30:54.34,0:30:56.78,English,,0,0,0,,Because all our examples were very simple
Dialogue: 0,0:30:54.34,0:30:56.78,Chinese,,0,0,0,,因为我们所有的例子都非常简单
Dialogue: 0,0:30:57.24,0:31:02.32,English,,0,0,0,,And just did a made use of the stack only for return addresses
Dialogue: 0,0:30:57.24,0:31:02.32,Chinese,,0,0,0,,并且只是将堆栈用于返回地址
Dialogue: 0,0:31:03.74,0:31:05.46,English,,0,0,0,,But we'll see some that uses more
Dialogue: 0,0:31:03.74,0:31:05.46,Chinese,,0,0,0,,但我们会看到一些更多使用栈的例子
Dialogue: 0,0:31:06.20,0:31:17.02,English,,0,0,0,,But so in general then imagine that each time you begin a function some space gets allocated potentially on the stack for its frame
Dialogue: 0,0:31:06.20,0:31:17.02,Chinese,,0,0,0,,但总的来说，想象一下，每次开始一个函数时，一些空间可能会在栈中为其框架分配
Dialogue: 0,0:31:17.64,0:31:25.91,English,,0,0,0,,And then and that frame is indicated by either one pointer only or two pointers
Dialogue: 0,0:31:17.64,0:31:25.91,Chinese,,0,0,0,,然后，该帧由一个指针或两个指针指示
Dialogue: 0,0:31:27.66,0:31:33.45,English,,0,0,0,,And so now as "yoo" calls "who" then that will create a new stack frame for "who"
Dialogue: 0,0:31:27.66,0:31:33.45,Chinese,,0,0,0,,所以现在因为?yoo"调用"who"然后将为"who"创建一个新的栈帧
Dialogue: 0,0:31:33.96,0:31:37.94,English,,0,0,0,,In some way when "amI" gets called that creates a new stack frame
Dialogue: 0,0:31:33.96,0:31:37.94,Chinese,,0,0,0,,以某种方式调用“amI”时会创建一个新的栈帧
Dialogue: 0,0:31:38.64,0:31:41.20,English,,0,0,0,,And as we continue with these recursive calls
Dialogue: 0,0:31:38.64,0:31:41.20,Chinese,,0,0,0,,当我们继续这些递归调用时
Dialogue: 0,0:31:41.20,0:31:44.70,English,,0,0,0,,We're just adding more stuff to the stack getting deeper and deeper
Dialogue: 0,0:31:41.20,0:31:44.70,Chinese,,0,0,0,,我们只是在栈中添加更多东西使它越来越深
Dialogue: 0,0:31:45.38,0:31:50.52,English,,0,0,0,,And that will keep happening that's one of the reasons why recursion is a little bit of a risky thing
Dialogue: 0,0:31:45.38,0:31:50.52,Chinese,,0,0,0,,这将不断进行，递归有点冒险的原因之一是：
Dialogue: 0,0:31:51.04,0:31:53.54,English,,0,0,0,,Is that it compared to iteration
Dialogue: 0,0:31:51.04,0:31:53.54,Chinese,,0,0,0,,与迭代相比
Dialogue: 0,0:31:54.12,0:31:58.40,English,,0,0,0,,It keeps requiring more space as you go deeper in the recursion
Dialogue: 0,0:31:54.12,0:31:58.40,Chinese,,0,0,0,,随着你在递归中的深入，它不断需要更多空间
Dialogue: 0,0:31:58.84,0:32:04.78,English,,0,0,0,,And in particular most systems limit the total depth of the stack
Dialogue: 0,0:31:58.84,0:32:04.78,Chinese,,0,0,0,,特别地，大多数系统限制了栈的总深度
Dialogue: 0,0:32:06.54,0:32:08.30,English,,0,0,0,,And you can have what
Dialogue: 0,0:32:06.54,0:32:08.30,Chinese,,0,0,0,,你可以理解
Dialogue: 0,0:32:08.56,0:32:12.68,English,,0,0,0,,Because they're afraid of the sort of infinite loop version of recursion is
Dialogue: 0,0:32:08.56,0:32:12.68,Chinese,,0,0,0,,因为他们害怕那种无限循环版本的递归
Dialogue: 0,0:32:12.98,0:32:16.98,English,,0,0,0,,Runaway recursion where it just keeps trying to push more and more stuff onto the stack
Dialogue: 0,0:32:12.98,0:32:16.98,Chinese,,0,0,0,,失控的递归，它只是不断尝试将越来越多的东西压入栈
Dialogue: 0,0:32:17.66,0:32:18.96,English,,0,0,0,,That's an aside
Dialogue: 0,0:32:17.66,0:32:18.96,Chinese,,0,0,0,,那是题外话了
Dialogue: 0,0:32:21.22,0:32:29.26,English,,0,0,0,,And then as these begin to return they those frames get deallocated removed from the stack
Dialogue: 0,0:32:21.22,0:32:29.26,Chinese,,0,0,0,,然后当这些开始返回时，这些帧将从栈中被释放
Dialogue: 0,0:32:29.86,0:32:34.22,English,,0,0,0,,So part of it the nice thing about this is it means that
Dialogue: 0,0:32:29.86,0:32:34.22,Chinese,,0,0,0,,所以关于这一点的好处就是它意味着
Dialogue: 0,0:32:34.94,0:32:38.18,English,,0,0,0,,Every time I if I have multiple calls to "amI"
Dialogue: 0,0:32:34.94,0:32:38.18,Chinese,,0,0,0,,每当我有多次调用“amI”
Dialogue: 0,0:32:38.52,0:32:46.34,English,,0,0,0,,Because I've gone deep recursively each one of them will have its own local state that it needs to manage
Dialogue: 0,0:32:38.52,0:32:46.34,Chinese,,0,0,0,,因为我深层递归，所以每层都会有自己需要管理的局部状态
Dialogue: 0,0:32:46.72,0:32:51.62,English,,0,0,0,,And again the whole stack discipline is what makes it work
Dialogue: 0,0:32:46.72,0:32:51.62,Chinese,,0,0,0,,是整个栈的规则保证它工作
Dialogue: 0,0:32:53.30,0:32:57.10,English,,0,0,0,,And what we'll find out in particular is because of the way this is set up
Dialogue: 0,0:32:53.30,0:32:57.10,Chinese,,0,0,0,,特别地我们会发现，因为它的设置方式
Dialogue: 0,0:32:57.92,0:33:01.82,English,,0,0,0,,Recursive calls are handled the same way that regular calls are
Dialogue: 0,0:32:57.92,0:33:01.82,Chinese,,0,0,0,,递归调用的处理方式与常规调用相同
Dialogue: 0,0:33:01.82,0:33:03.62,English,,0,0,0,,There's nothing special about them
Dialogue: 0,0:33:01.82,0:33:03.62,Chinese,,0,0,0,,他们没什么特别的
Dialogue: 0,0:33:03.62,0:33:10.80,English,,0,0,0,,All the sort of infrastructure required to support recursion is built into this whole stack discipline
Dialogue: 0,0:33:03.62,0:33:10.80,Chinese,,0,0,0,,支持递归所需的所有基础结构都内置于整个栈规程中
Dialogue: 0,0:33:13.56,0:33:18.64,English,,0,0,0,,So anyways imagine that all these calls are returned back to "who"
Dialogue: 0,0:33:13.56,0:33:18.64,Chinese,,0,0,0,,所以无论如何，想象所有这些调用都将返回给"who"
Dialogue: 0,0:33:18.96,0:33:21.76,English,,0,0,0,,And then "who" would call "amI" again
Dialogue: 0,0:33:18.96,0:33:21.76,Chinese,,0,0,0,,然后"who"再次调用"amI"
Dialogue: 0,0:33:22.36,0:33:27.18,English,,0,0,0,,And then again as we exit we were sort of deallocating these stack frames
Dialogue: 0,0:33:22.36,0:33:27.18,Chinese,,0,0,0,,然后当我们退出时，我们释放这些栈帧
Dialogue: 0,0:33:27.64,0:33:30.04,English,,0,0,0,,And getting back to the the starting point
Dialogue: 0,0:33:27.64,0:33:30.04,Chinese,,0,0,0,,并回到起点
Dialogue: 0,0:33:31.18,0:33:31.90,English,,0,0,0,,Yes question
Dialogue: 0,0:33:31.18,0:33:31.90,Chinese,,0,0,0,,是的问题
Dialogue: 0,0:33:32.72,0:33:37.42,English,,0,0,0,,[student speaking]
Dialogue: 0,0:33:32.72,0:33:37.42,Chinese,,0,0,0,,[学生说话]
Dialogue: 0,0:33:37.42,0:33:44.66,English,,0,0,0,,Oh so the question was if %rbp is optional then how does the program know how to do the deallocation
Dialogue: 0,0:33:37.42,0:33:44.66,Chinese,,0,0,0,,哦，问题是既然％rbp是可选的那么程序怎么知道如何释放空间
Dialogue: 0,0:33:44.66,0:33:47.48,English,,0,0,0,,How can it reset the stack back to the right place
Dialogue: 0,0:33:44.66,0:33:47.48,Chinese,,0,0,0,,如何将栈重置回正确的位置
Dialogue: 0,0:33:48.10,0:33:53.42,English,,0,0,0,,And the answer is and we'll see examples that the code is compiled
Dialogue: 0,0:33:48.10,0:33:53.42,Chinese,,0,0,0,,答案是，我们将看到代码编译的示例
Dialogue: 0,0:33:53.90,0:33:59.90,English,,0,0,0,,So it knows for example when it does the allocation it's going to allocate 16 bytes
Dialogue: 0,0:33:53.90,0:33:59.90,Chinese,,0,0,0,,例如，它知道当它分配时，它将分配16个字节
Dialogue: 0,0:34:00.52,0:34:04.14,English,,0,0,0,,And then it knows at the end that it can deallocated 16 bytes
Dialogue: 0,0:34:00.52,0:34:04.14,Chinese,,0,0,0,,然后它最终知道可以释放16个字节
Dialogue: 0,0:34:04.78,0:34:06.32,English,,0,0,0,,And it actually brings up a good point
Dialogue: 0,0:34:04.78,0:34:06.32,Chinese,,0,0,0,,实际上你提出了一个重点
Dialogue: 0,0:34:06.32,0:34:10.30,English,,0,0,0,,There is sort of an obscure part of the book that goes over this
Dialogue: 0,0:34:06.32,0:34:10.30,Chinese,,0,0,0,,这本书有一个关于这一点的模糊的部分
Dialogue: 0,0:34:10.74,0:34:16.02,English,,0,0,0,,There's a few special cases where it can't know in advance how much space will be allocated
Dialogue: 0,0:34:10.74,0:34:16.02,Chinese,,0,0,0,,有一些特殊情况，它无法提前知道将分配多少空间
Dialogue: 0,0:34:18.34,0:34:23.42,English,,0,0,0,,When it has to allocate an array or a memory buffer of variable size
Dialogue: 0,0:34:18.34,0:34:23.42,Chinese,,0,0,0,,当它必须分配一个可变大小的数组或内存缓冲区时
Dialogue: 0,0:34:23.92,0:34:29.28,English,,0,0,0,,And then it will actually use the the %rbp in those cases for exactly that purpose
Dialogue: 0,0:34:23.92,0:34:29.28,Chinese,,0,0,0,,然后它实际上会在这些情况下使用％rbp来实现这个目的
Dialogue: 0,0:34:34.34,0:34:46.20,English,,0,0,0,,Okay and so in general that what the stack frame will look like in one of these machines will be something like this that
Dialogue: 0,0:34:34.34,0:34:46.20,Chinese,,0,0,0,,好的，所以一般来说，栈帧在某一台机器上一般会是这样的
Dialogue: 0,0:34:47.16,0:34:50.46,English,,0,0,0,,The and you'll see this is the caller
Dialogue: 0,0:34:47.16,0:34:50.46,Chinese,,0,0,0,,你会看到这是调用者
Dialogue: 0,0:34:52.00,0:34:57.56,English,,0,0,0,,And then this is the the stack frame of the the function that got called
Dialogue: 0,0:34:52.00,0:34:57.56,Chinese,,0,0,0,,然后这是被调用函数的栈帧
Dialogue: 0,0:34:58.54,0:35:00.98,English,,0,0,0,,So working our way back
Dialogue: 0,0:34:58.54,0:35:00.98,Chinese,,0,0,0,,所以回过头来
Dialogue: 0,0:35:01.56,0:35:04.94,English,,0,0,0,,If we have to pass more than six arguments
Dialogue: 0,0:35:01.56,0:35:04.94,Chinese,,0,0,0,,如果我们必须传递六个以上的参数
Dialogue: 0,0:35:05.52,0:35:13.10,English,,0,0,0,,The caller will actually use its own stack frame to store those arguments
Dialogue: 0,0:35:05.52,0:35:13.10,Chinese,,0,0,0,,调用者实际上将使用自己的栈帧来存储这些参数
Dialogue: 0,0:35:15.06,0:35:17.32,English,,0,0,0,,And so that they'd be available
Dialogue: 0,0:35:15.06,0:35:17.32,Chinese,,0,0,0,,这样参数就能拿到了
Dialogue: 0,0:35:17.84,0:35:20.32,English,,0,0,0,,And we already saw when you do a call
Dialogue: 0,0:35:17.84,0:35:20.32,Chinese,,0,0,0,,我们已经看到当你调用时
Dialogue: 0,0:35:20.76,0:35:23.60,English,,0,0,0,,It will push the return address onto the stack
Dialogue: 0,0:35:20.76,0:35:23.60,Chinese,,0,0,0,,它会将返回地址压入栈
Dialogue: 0,0:35:24.30,0:35:29.72,English,,0,0,0,,So before our function even starts all this information would be on the stack
Dialogue: 0,0:35:24.30,0:35:29.72,Chinese,,0,0,0,,所以在我们的函数开始之前，所有这些信息都将在堆栈中
Dialogue: 0,0:35:30.96,0:35:37.40,English,,0,0,0,,Now if there's a if this particular if we're making use of a base pointer
Dialogue: 0,0:35:30.96,0:35:37.40,Chinese,,0,0,0,,如果我们正在使用基指针，那么如果有这个特殊情况的话
Dialogue: 0,0:35:37.68,0:35:41.26,English,,0,0,0,,Then we have to have some way where to store the old value of the base pointer
Dialogue: 0,0:35:37.68,0:35:41.26,Chinese,,0,0,0,,然后我们必须有一些方法来存储基指针的旧值
Dialogue: 0,0:35:41.26,0:35:44.34,English,,0,0,0,,So that we could fix it back when we return
Dialogue: 0,0:35:41.26,0:35:44.34,Chinese,,0,0,0,,这样我们就可以在返回时修复它
Dialogue: 0,0:35:45.04,0:35:48.40,English,,0,0,0,,We won't show any code doing that here so this is optional
Dialogue: 0,0:35:45.04,0:35:48.40,Chinese,,0,0,0,,我们不会在此处显示任何代码，因此这是可选的
Dialogue: 0,0:35:49.06,0:35:51.58,English,,0,0,0,,But in general if there's some local state
Dialogue: 0,0:35:49.06,0:35:51.58,Chinese,,0,0,0,,但总的来说，如果有一些局部状态
Dialogue: 0,0:35:52.52,0:35:56.40,English,,0,0,0,,Like some registers that need to be saved and we'll see examples of that
Dialogue: 0,0:35:52.52,0:35:56.40,Chinese,,0,0,0,,像一些需要保存的寄存器，我们会看到它的例子
Dialogue: 0,0:35:56.84,0:35:59.60,English,,0,0,0,,Or an array that needs to be allocated locally
Dialogue: 0,0:35:56.84,0:35:59.60,Chinese,,0,0,0,,或者需要在局部分配的数组
Dialogue: 0,0:36:00.06,0:36:03.32,English,,0,0,0,,That will be stored within the stack frame
Dialogue: 0,0:36:00.06,0:36:03.32,Chinese,,0,0,0,,那将存储在栈帧内
Dialogue: 0,0:36:03.84,0:36:08.90,English,,0,0,0,,And there might be some requirement for some extra space in the stack frame for other stuff
Dialogue: 0,0:36:03.84,0:36:08.90,Chinese,,0,0,0,,对于其他东西，可能需要在堆栈帧中增加一些空间
Dialogue: 0,0:36:09.48,0:36:15.86,English,,0,0,0,,In particular if it we're going to pass more than seven arguments it needs space somewhere in the stack frame to do it
Dialogue: 0,0:36:09.48,0:36:15.86,Chinese,,0,0,0,,特别是如果我们要传递超过七个参数，它需要在栈帧中分配空间
Dialogue: 0,0:36:16.56,0:36:19.50,English,,0,0,0,,And what we'll see in typical a code is
Dialogue: 0,0:36:16.56,0:36:19.50,Chinese,,0,0,0,,我们在典型代码中会看到的是
Dialogue: 0,0:36:19.98,0:36:26.56,English,,0,0,0,,This stack pointer gets decremented pretty soon after the procedure begins
Dialogue: 0,0:36:19.98,0:36:26.56,Chinese,,0,0,0,,程序开始后，这个堆栈指针很快就会减少
Dialogue: 0,0:36:26.88,0:36:29.88,English,,0,0,0,,And it gets incremented back just before it returns
Dialogue: 0,0:36:26.88,0:36:29.88,Chinese,,0,0,0,,它会在返回之前递增
Dialogue: 0,0:36:30.62,0:36:32.38,English,,0,0,0,,That's how it manages this stack
Dialogue: 0,0:36:30.62,0:36:32.38,Chinese,,0,0,0,,这就是它如何管理栈的
Dialogue: 0,0:36:34.50,0:36:36.38,English,,0,0,0,,So let's do some examples
Dialogue: 0,0:36:34.50,0:36:36.38,Chinese,,0,0,0,,让我们举一些例子吧
Dialogue: 0,0:36:41.68,0:36:48.42,English,,0,0,0,,Um let's see look at this before
Dialogue: 0,0:36:41.68,0:36:48.42,Chinese,,0,0,0,,嗯，让我们看看...
Dialogue: 0,0:36:48.58,0:36:49.98,English,,0,0,0,,But this is a function
Dialogue: 0,0:36:48.58,0:36:49.98,Chinese,,0,0,0,,但这是一个函数
Dialogue: 0,0:36:50.06,0:36:55.20,English,,0,0,0,,Oh I think the interesting thing about this function is that it has a pointer being passed to it
Dialogue: 0,0:36:50.06,0:36:55.20,Chinese,,0,0,0,,哦，我认为这个函数的有趣之处在于它有一个传递给它的指针
Dialogue: 0,0:36:56.08,0:36:58.20,English,,0,0,0,,So this function takes an argument
Dialogue: 0,0:36:56.08,0:36:58.20,Chinese,,0,0,0,,所以这个函数需要一个参数
Dialogue: 0,0:36:58.22,0:37:02.38,English,,0,0,0,,One argument is a pointer and another is a an integer value
Dialogue: 0,0:36:58.22,0:37:02.38,Chinese,,0,0,0,,一个参数是指针，另一个是整型
Dialogue: 0,0:37:03.26,0:37:09.88,English,,0,0,0,,And you can see what it does is it dereferences that pointer to get a value called x
Dialogue: 0,0:37:03.26,0:37:09.88,Chinese,,0,0,0,,你可以看到它的作用：它从指针中获取x的值
Dialogue: 0,0:37:11.20,0:37:17.94,English,,0,0,0,,It computes a value y by summing x and the value passed to it
Dialogue: 0,0:37:11.20,0:37:17.94,Chinese,,0,0,0,,它通过将x和传递给它的值相加来计算值y
Dialogue: 0,0:37:18.56,0:37:20.84,English,,0,0,0,,It stores y back at p
Dialogue: 0,0:37:18.56,0:37:20.84,Chinese,,0,0,0,,它将y存储回p
Dialogue: 0,0:37:21.36,0:37:27.63,English,,0,0,0,,But it returns x the original value of the pointer not the updated version of the pointer
Dialogue: 0,0:37:21.36,0:37:27.63,Chinese,,0,0,0,,但它返回的x是指针的原始值而不是更新后的值
Dialogue: 0,0:37:28.16,0:37:30.04,English,,0,0,0,,And you can see that in the code here
Dialogue: 0,0:37:28.16,0:37:30.04,Chinese,,0,0,0,,你可以在代码中看到这一点
Dialogue: 0,0:37:30.16,0:37:37.48,English,,0,0,0,,Its code's pretty short remember that in general %rdi will hold the first argument,in this case it's a pointer
Dialogue: 0,0:37:30.16,0:37:37.48,Chinese,,0,0,0,,它的代码非常简短，记住通常％rdi将保存第一个参数，在这种情况下它是一个指针
Dialogue: 0,0:37:38.12,0:37:40.08,English,,0,0,0,,So we'll do a read from that pointer
Dialogue: 0,0:37:38.12,0:37:40.08,Chinese,,0,0,0,,所以我们将从该指针读取
Dialogue: 0,0:37:40.88,0:37:46.44,English,,0,0,0,,And it will put the value in %rax which is where the return value should be anyhow
Dialogue: 0,0:37:40.88,0:37:46.44,Chinese,,0,0,0,,并且它会将值放在％rax中，这也是返回值所在的地方
Dialogue: 0,0:37:47.48,0:37:56.76,English,,0,0,0,,And then it will increment %rsi which has the value called val here initially and now it has the value of x + val
Dialogue: 0,0:37:47.48,0:37:56.76,Chinese,,0,0,0,,然后它将增加％rsi，其最初具有名为val的值，现在它具有x + val的值
Dialogue: 0,0:37:58.08,0:38:07.48,English,,0,0,0,,And then it will store that in...the value pointed to by p
Dialogue: 0,0:37:58.08,0:38:07.48,Chinese,,0,0,0,,然后它会将其存储在p指向的值中
Dialogue: 0,0:38:08.14,0:38:12.76,English,,0,0,0,,And it will do a return,so you see these three instructions do all the different parts of this
Dialogue: 0,0:38:08.14,0:38:12.76,Chinese,,0,0,0,,它会返回，所以你看到这三个指令完成了所有不同的部分
Dialogue: 0,0:38:13.54,0:38:18.06,English,,0,0,0,,And as this shows in general also you know register usage
Dialogue: 0,0:38:13.54,0:38:18.06,Chinese,,0,0,0,,而且，这一般表明你也知道寄存器的使用情况
Dialogue: 0,0:38:18.32,0:38:21.02,English,,0,0,0,,By the way to document this when you're looking at code
Dialogue: 0,0:38:18.32,0:38:21.02,Chinese,,0,0,0,,当你查看代码时，请记录下来
Dialogue: 0,0:38:21.94,0:38:27.02,English,,0,0,0,,%rdi is the first argument %rsi gets used initially it's val
Dialogue: 0,0:38:21.94,0:38:27.02,Chinese,,0,0,0,,％rdi是第一个参数，％rsi最初的值是val
Dialogue: 0,0:38:27.34,0:38:31.14,English,,0,0,0,,But now it will be set to y during the call
Dialogue: 0,0:38:27.34,0:38:31.14,Chinese,,0,0,0,,但现在它将在调用期间设置为y
Dialogue: 0,0:38:31.68,0:38:41.02,English,,0,0,0,,And similarly %rax is initially the value well it's both what x is here and it's used as the return value
Dialogue: 0,0:38:31.68,0:38:41.02,Chinese,,0,0,0,,同样，％rax最初是x的值，同时被用作返回值
Dialogue: 0,0:38:42.50,0:38:49.20,English,,0,0,0,,Okay so what's up the reason to go through all that is to actually show you examples of calling this
Dialogue: 0,0:38:42.50,0:38:49.20,Chinese,,0,0,0,,好的，这就是为什么要通过所有这些来实际向你展示调用它的例子
Dialogue: 0,0:38:49.28,0:38:54.70,English,,0,0,0,,And how arguments get passed to the function and how it makes use of the stack frame
Dialogue: 0,0:38:49.28,0:38:54.70,Chinese,,0,0,0,,以及如何将参数传递给函数、如何使用栈帧
Dialogue: 0,0:38:56.74,0:38:59.66,English,,0,0,0,,So now there's a function called "call_incr"
Dialogue: 0,0:38:56.74,0:38:59.66,Chinese,,0,0,0,,所以现在有一个名为“call_incr”的函数
Dialogue: 0,0:39:00.68,0:39:08.18,English,,0,0,0,,And it's going to create a value called  v1 and have to generate a pointer to that
Dialogue: 0,0:39:00.68,0:39:08.18,Chinese,,0,0,0,,它将创建一个名为v1的值，并且必须生成一个指向该值的指针
Dialogue: 0,0:39:08.98,0:39:13.12,English,,0,0,0,,So what that means is v1 can't just stay in a register
Dialogue: 0,0:39:08.98,0:39:13.12,Chinese,,0,0,0,,那么这意味着v1不能只保存在寄存器中
Dialogue: 0,0:39:13.12,0:39:20.98,English,,0,0,0,,Because you can't create an address of a register,it has to be stored in memory somewhere so that you can create a pointer an address of it
Dialogue: 0,0:39:13.12,0:39:20.98,Chinese,,0,0,0,,因为你无法创建寄存器的地址，所以必须将其存储在内存的某处，这样你就可以创建一个指向它的地址
Dialogue: 0,0:39:21.58,0:39:25.58,English,,0,0,0,,And where is it stored? well it puts it in the stack
Dialogue: 0,0:39:21.58,0:39:25.58,Chinese,,0,0,0,,那么它存在哪里呢？在栈中
Dialogue: 0,0:39:26.54,0:39:29.78,English,,0,0,0,,So how does it find space on the stack while allocates
Dialogue: 0,0:39:26.54,0:39:29.78,Chinese,,0,0,0,,那么在分配时如何在栈上找到空间呢
Dialogue: 0,0:39:30.08,0:39:34.62,English,,0,0,0,,So the function "call_incr" then and we'll go through all the different parts of it
Dialogue: 0,0:39:30.08,0:39:34.62,Chinese,,0,0,0,,我们将遍历函数“call_incr”的所有不同部分
Dialogue: 0,0:39:34.62,0:39:45.98,English,,0,0,0,,But you see that this red code here (is generated) generates these two instructions one is to allocate 16 bytes on the stack
Dialogue: 0,0:39:34.62,0:39:45.98,Chinese,,0,0,0,,你看到这个红色的代码会生成两条指令，其一是在栈中分配16字节的空间
Dialogue: 0,0:39:46.78,0:39:53.76,English,,0,0,0,,And the other is to store $15213 at offset eight from the stack pointer
Dialogue: 0,0:39:46.78,0:39:53.76,Chinese,,0,0,0,,其二是在离栈指针的偏移量为8的地方存储常数15213
Dialogue: 0,0:39:54.46,0:40:02.32,English,,0,0,0,,And as will often see the the program often allocates more space on the stack than it really needs to
Dialogue: 0,0:39:54.46,0:40:02.32,Chinese,,0,0,0,,并且通常会看到程序经常在栈上分配比实际需要更多的空间
Dialogue: 0,0:40:02.82,0:40:11.38,English,,0,0,0,,And there's some conventions about trying to keep addresses on aligned in various ways
Dialogue: 0,0:40:02.82,0:40:11.38,Chinese,,0,0,0,,并且有一些关于尝试以各种方式保持地址对齐的约定
Dialogue: 0,0:40:11.56,0:40:18.10,English,,0,0,0,,That are sort of obscure and we you should just kind of not worry about the fact there's unused space and functions
Dialogue: 0,0:40:11.56,0:40:18.10,Chinese,,0,0,0,,这有点模糊，你不必担心有未使用的空间和功能
Dialogue: 0,0:40:18.10,0:40:24.58,English,,0,0,0,,Because they do it the reasons for doing it are...
Dialogue: 0,0:40:18.10,0:40:24.58,Chinese,,0,0,0,,因为他们这样做的原因是......
Dialogue: 0,0:40:26.16,0:40:31.12,English,,0,0,0,,Maybe interesting to some but not really ones you need to understand at this point
Dialogue: 0,0:40:26.16,0:40:31.12,Chinese,,0,0,0,,对某些人来说可能很有趣，但在这一点上你不需要理解
Dialogue: 0,0:40:32.60,0:40:40.50,English,,0,0,0,,So the point being that the way we got space on the stack was to just (add to the stack pointer) decrement the stack pointer
Dialogue: 0,0:40:32.60,0:40:40.50,Chinese,,0,0,0,,所以关键是我们在栈上获得空间的方式是递减堆栈指针
Dialogue: 0,0:40:42.36,0:40:48.08,English,,0,0,0,,So now we have a number 15213 that's sitting in memory
Dialogue: 0,0:40:42.36,0:40:48.08,Chinese,,0,0,0,,所以现在我们在内存中有一个数字15213
Dialogue: 0,0:40:48.64,0:40:51.42,English,,0,0,0,,And we can create a pointer to it
Dialogue: 0,0:40:48.64,0:40:51.42,Chinese,,0,0,0,,我们可以创建一个指向它的指针
Dialogue: 0,0:40:54.72,0:41:08.40,English,,0,0,0,,And so now to set up this call, we need to create a pointer to v1 and we have to pass the number 3000
Dialogue: 0,0:40:54.72,0:41:08.40,Chinese,,0,0,0,,所以现在要设置这个调用，我们需要创建一个指针指向v1，然后传递数字3000
Dialogue: 0,0:41:09.12,0:41:13.46,English,,0,0,0,,So we'll see that will copy 3000 to register %esi
Dialogue: 0,0:41:09.12,0:41:13.46,Chinese,,0,0,0,,所以我们会看到代码将3000复制到寄存器％esi
Dialogue: 0,0:41:14.26,0:41:17.42,English,,0,0,0,,And let me just double check here
Dialogue: 0,0:41:14.26,0:41:17.42,Chinese,,0,0,0,,让我在这里仔细检查一下
Dialogue: 0,0:41:24.68,0:41:25.96,English,,0,0,0,,Just looking
Dialogue: 0,0:41:24.68,0:41:25.96,Chinese,,0,0,0,,只是看看
Dialogue: 0,0:41:26.22,0:41:28.42,English,,0,0,0,,So one of the annoying features is
Dialogue: 0,0:41:26.22,0:41:28.42,Chinese,,0,0,0,,所以令人讨厌的功能之一就是
Dialogue: 0,0:41:28.66,0:41:32.06,English,,0,0,0,,You see all the data type here are long,so there's no ints here
Dialogue: 0,0:41:28.66,0:41:32.06,Chinese,,0,0,0,,你看到这里的所有数据类型都是long，所以这里没有int
Dialogue: 0,0:41:33.06,0:41:37.80,English,,0,0,0,,And yet it's copying 3,000 just to register %esi and not %rsi
Dialogue: 0,0:41:33.06,0:41:37.80,Chinese,,0,0,0,,然而它只是复制3,000到寄存器％esi而不是％rsi
Dialogue: 0,0:41:38.34,0:41:40.46,English,,0,0,0,,And it's using a movl and not a movq
Dialogue: 0,0:41:38.34,0:41:40.46,Chinese,,0,0,0,,它使用的是movl而不是movq
Dialogue: 0,0:41:41.16,0:41:42.94,English,,0,0,0,,I think we might have covered that last time
Dialogue: 0,0:41:41.16,0:41:42.94,Chinese,,0,0,0,,我想我们上次可能讲到了
Dialogue: 0,0:41:42.94,0:41:47.36,English,,0,0,0,,But 3,000 is a small enough number it will fit in 32 bits
Dialogue: 0,0:41:42.94,0:41:47.36,Chinese,,0,0,0,,但3,000是一个足够小的数字，它将适合32位
Dialogue: 0,0:41:47.78,0:41:50.86,English,,0,0,0,,It's a positive number so we don't have to worry about sign bits
Dialogue: 0,0:41:47.78,0:41:50.86,Chinese,,0,0,0,,这是一个正数，所以我们不必担心符号位
Dialogue: 0,0:41:51.34,0:41:57.58,English,,0,0,0,,So the thing can sort of get away with a trick here of using just a movl instruction
Dialogue: 0,0:41:51.34,0:41:57.58,Chinese,,0,0,0,,因此，只需使用一个movl指令就可以解决这个问题
Dialogue: 0,0:41:58.10,0:42:05.56,English,,0,0,0,,Because when any instruction has a one of the e register as its destination
Dialogue: 0,0:41:58.10,0:42:05.56,Chinese,,0,0,0,,当一个指令以e开头寄存器作为目的地时
Dialogue: 0,0:42:05.96,0:42:12.46,English,,0,0,0,,It will set the upper 32 bits of that register to zeros
Dialogue: 0,0:42:05.96,0:42:12.46,Chinese,,0,0,0,,它会将该寄存器的高32位设置为零
Dialogue: 0,0:42:13.16,0:42:17.44,English,,0,0,0,,So this will have the effect of copying the number 3000
Dialogue: 0,0:42:13.16,0:42:17.44,Chinese,,0,0,0,,因此，这将具有复制数字3000的效果
Dialogue: 0,0:42:18.18,0:42:21.06,English,,0,0,0,,And zeroing out the upper bytes to register %rsi
Dialogue: 0,0:42:18.18,0:42:21.06,Chinese,,0,0,0,,对于寄存器%rsi来说则使高位清零
Dialogue: 0,0:42:21.66,0:42:28.44,English,,0,0,0,,And the reason the compiler likes this is it takes one less byte to encode a movl than it does to encode a movq
Dialogue: 0,0:42:21.66,0:42:28.44,Chinese,,0,0,0,,编译器喜欢这个的原因是movl比movq少一个字节
Dialogue: 0,0:42:30.04,0:42:33.96,English,,0,0,0,,Um so just you have to get used to these kind of things
Dialogue: 0,0:42:30.04,0:42:33.96,Chinese,,0,0,0,,嗯所以你必须习惯这些事情
Dialogue: 0,0:42:34.46,0:42:38.40,English,,0,0,0,,So that's setting up argument the the second argument to the call
Dialogue: 0,0:42:34.46,0:42:38.40,Chinese,,0,0,0,,这就是设置调用的第二个参数的过程
Dialogue: 0,0:42:39.88,0:42:49.61,English,,0,0,0,,But the first argument it's using this instruction lea or leaq for what it's supposed to be used for,which is to create pointers
Dialogue: 0,0:42:39.88,0:42:49.61,Chinese,,0,0,0,,但是它的第一个参数是使用这个指令lea或leaq用于它本来应该做的，即创建指针
Dialogue: 0,0:42:50.22,0:42:54.82,English,,0,0,0,,Remember we talked about this instruction often getting used just to add two numbers
Dialogue: 0,0:42:50.22,0:42:54.82,Chinese,,0,0,0,,记得我们说过这个指令经常被用来做两个数字的加法
Dialogue: 0,0:42:55.78,0:42:58.84,English,,0,0,0,,But it's actually designed exactly for this purpose
Dialogue: 0,0:42:55.78,0:42:58.84,Chinese,,0,0,0,,但它实际上是为此目的而设计的
Dialogue: 0,0:42:59.54,0:43:04.66,English,,0,0,0,,That it looks like a memory reference 8 relative to the stack pointer
Dialogue: 0,0:42:59.54,0:43:04.66,Chinese,,0,0,0,,它看起来像是与栈指针相邻8字节的内存引用
Dialogue: 0,0:43:06.38,0:43:14.24,English,,0,0,0,,But instead of now reading from that memory reference the instruction will just copy the computed address to %rdi
Dialogue: 0,0:43:06.38,0:43:14.24,Chinese,,0,0,0,,但是与从该内存引用读取数据不同，该指令会直接将计算的地址复制给%rdi
Dialogue: 0,0:43:17.78,0:43:25.72,English,,0,0,0,,And so %rdi will now be equal to whatever the stack pointer plus 8
Dialogue: 0,0:43:17.78,0:43:25.72,Chinese,,0,0,0,,所以％rdi现在将等于栈指针加上8
Dialogue: 0,0:43:28.10,0:43:32.40,English,,0,0,0,,Okay so that creates the two arguments that I'm passing to this function
Dialogue: 0,0:43:28.10,0:43:32.40,Chinese,,0,0,0,,好的，这样就创建了我传递给这个函数的两个参数
Dialogue: 0,0:43:33.56,0:43:36.94,English,,0,0,0,,And now the call instruction will happen
Dialogue: 0,0:43:33.56,0:43:36.94,Chinese,,0,0,0,,现在调用指令将会发生
Dialogue: 0,0:43:37.60,0:43:45.30,English,,0,0,0,,And you'll recall that the call instruction adds(3000)these two numbers and stores the result back in the pointer
Dialogue: 0,0:43:37.60,0:43:45.30,Chinese,,0,0,0,,你会记得call指令将两个数字相加并将结果存储回指针
Dialogue: 0,0:43:46.00,0:43:53.18,English,,0,0,0,,So its effect will be to set the of this memory location to 18213
Dialogue: 0,0:43:46.00,0:43:53.18,Chinese,,0,0,0,,因此它的作用是将此内存位置设置为18213
Dialogue: 0,0:43:53.74,0:43:55.72,English,,0,0,0,,You'll notice the clever trick here
Dialogue: 0,0:43:53.74,0:43:55.72,Chinese,,0,0,0,,你会注意到这里的聪明伎俩
Dialogue: 0,0:43:56.24,0:44:00.90,English,,0,0,0,,And also return a particular value
Dialogue: 0,0:43:56.24,0:44:00.90,Chinese,,0,0,0,,并且还返回特定值
Dialogue: 0,0:44:01.14,0:44:03.50,English,,0,0,0,,Which we won't make use of the return value
Dialogue: 0,0:44:01.14,0:44:03.50,Chinese,,0,0,0,,我们不会使用返回值
Dialogue: 0,0:44:04.18,0:44:06.82,English,,0,0,0,,No we do make use of the return value
Dialogue: 0,0:44:04.18,0:44:06.82,Chinese,,0,0,0,,不，我们确实使用了返回值
Dialogue: 0,0:44:09.92,0:44:11.24,English,,0,0,0,,And now the...
Dialogue: 0,0:44:09.92,0:44:11.24,Chinese,,0,0,0,,现在......
Dialogue: 0,0:44:16.90,0:44:18.74,English,,0,0,0,,Now when we return back
Dialogue: 0,0:44:16.90,0:44:18.74,Chinese,,0,0,0,,现在我们回来的时候
Dialogue: 0,0:44:20.12,0:44:27.22,English,,0,0,0,,What we want to do is add the value in v1 to the value we just computed
Dialogue: 0,0:44:20.12,0:44:27.22,Chinese,,0,0,0,,我们想要做的是将v1中的值加到我们刚刚计算的值中
Dialogue: 0,0:44:27.22,0:44:29.92,English,,0,0,0,,The value we just computed is in v2
Dialogue: 0,0:44:27.22,0:44:29.92,Chinese,,0,0,0,,我们刚刚计算的值是v2
Dialogue: 0,0:44:30.70,0:44:38.24,English,,0,0,0,,And we know that the v1 is designated by this memory location that %rsp+8
Dialogue: 0,0:44:30.70,0:44:38.24,Chinese,,0,0,0,,我们知道v1内存位置指定为％rsp + 8
Dialogue: 0,0:44:38.62,0:44:43.00,English,,0,0,0,,And so we'll just read from memory to include that to %rax
Dialogue: 0,0:44:38.62,0:44:43.00,Chinese,,0,0,0,,所以我们只是从内存中读取，将其包含在％rax中
Dialogue: 0,0:44:44.90,0:44:48.92,English,,0,0,0,,And then the final step is to deallocate,so you see the match here
Dialogue: 0,0:44:44.90,0:44:48.92,Chinese,,0,0,0,,然后最后一步是取消分配，所以你在这里看到是匹配的
Dialogue: 0,0:44:49.68,0:44:56.66,English,,0,0,0,,And this was to answer the question earlier how does it know how to restore the the stack back to its original place?
Dialogue: 0,0:44:49.68,0:44:56.66,Chinese,,0,0,0,,这是为了回答这个问题，它是怎么知道如何将栈恢复到原来的位置？
Dialogue: 0,0:44:57.18,0:45:02.90,English,,0,0,0,,Well the compiler you know built into it figured out how much space it would need for this particular function
Dialogue: 0,0:44:57.18,0:45:02.90,Chinese,,0,0,0,,那么内置编译器会计算出这个特定函数需要多少空间
Dialogue: 0,0:45:03.52,0:45:07.54,English,,0,0,0,,And it allocates that when it comes in,and it deallocates it when it goes out
Dialogue: 0,0:45:03.52,0:45:07.54,Chinese,,0,0,0,,并且它在它被调用时分配它，并在它结束时时释放它
Dialogue: 0,0:45:09.94,0:45:13.86,English,,0,0,0,,So and this you know this is a very simple example
Dialogue: 0,0:45:09.94,0:45:13.86,Chinese,,0,0,0,,所以，你知道这是一个非常简单的例子
Dialogue: 0,0:45:13.86,0:45:17.94,English,,0,0,0,,But even more elaborate examples are still based on that same set of ideas
Dialogue: 0,0:45:13.86,0:45:17.94,Chinese,,0,0,0,,但更精细的例子仍然基于同样的想法
Dialogue: 0,0:45:19.80,0:45:25.02,English,,0,0,0,,So that shows you in 1 then the data management the stack management
Dialogue: 0,0:45:19.80,0:45:25.02,Chinese,,0,0,0,,这样就可以在一个例子显示数据管理，栈管理
Dialogue: 0,0:45:25.02,0:45:27.02,English,,0,0,0,,The idea of using a stack frame
Dialogue: 0,0:45:25.02,0:45:27.02,Chinese,,0,0,0,,使用栈帧的想法
Dialogue: 0,0:45:30.64,0:45:37.14,English,,0,0,0,,And now the return by this point the only thing that's left is
Dialogue: 0,0:45:30.64,0:45:37.14,Chinese,,0,0,0,,而现在通过这一点返回了，唯一剩下的就是
Dialogue: 0,0:45:38.26,0:45:42.84,English,,0,0,0,,After I increment the stack pointer it will be pointing back to this return address
Dialogue: 0,0:45:38.26,0:45:42.84,Chinese,,0,0,0,,在我递增堆栈指针后，它将指向此返回地址
Dialogue: 0,0:45:44.28,0:45:46.22,English,,0,0,0,,Whoops wrong direction here
Dialogue: 0,0:45:44.28,0:45:46.22,Chinese,,0,0,0,,哦弄错了
Dialogue: 0,0:45:46.78,0:45:54.48,English,,0,0,0,,So now if I do a ret. the ret instruction will always take whatever is pointed to by the stack pointer and use that as the return address
Dialogue: 0,0:45:46.78,0:45:54.48,Chinese,,0,0,0,,所以现在如果我做一个ret。 ret指令将始终采用栈指针指向的地址并将它作为返回地址
Dialogue: 0,0:45:56.16,0:46:01.94,English,,0,0,0,,So it's very important that %rsp get set back to where it should be before you it does a ret
Dialogue: 0,0:45:56.16,0:46:01.94,Chinese,,0,0,0,,所以％rsp在你进行ret之前应该回到它应该的位置是非常重要的
Dialogue: 0,0:46:05.50,0:46:08.20,English,,0,0,0,,Okay so that's sort of the the basic principles
Dialogue: 0,0:46:05.50,0:46:08.20,Chinese,,0,0,0,,好的，这就是基本原则
Dialogue: 0,0:46:08.20,0:46:12.18,English,,0,0,0,,Now let's get a little bit more refined
Dialogue: 0,0:46:08.20,0:46:12.18,Chinese,,0,0,0,,现在让我们更精致一点
Dialogue: 0,0:46:12.72,0:46:17.12,English,,0,0,0,,An important idea is...well what about these registers
Dialogue: 0,0:46:12.72,0:46:17.12,Chinese,,0,0,0,,一个重要的想法是......那么这些寄存器呢
Dialogue: 0,0:46:17.12,0:46:23.50,English,,0,0,0,,What can be assumed about particularly registers and how they get changed and so forth
Dialogue: 0,0:46:17.12,0:46:23.50,Chinese,,0,0,0,,对于寄存器有什么假设或者它们有什么变化
Dialogue: 0,0:46:23.98,0:46:29.98,English,,0,0,0,,And so again it's built into this idea of an ABI is a set of conventions about the register
Dialogue: 0,0:46:23.98,0:46:29.98,Chinese,,0,0,0,,因此，ABI再次构建了一套关于寄存器的约定
Dialogue: 0,0:46:29.98,0:46:33.10,English,,0,0,0,,Obviously %rsp is a very important register
Dialogue: 0,0:46:29.98,0:46:33.10,Chinese,,0,0,0,,显然％rsp是一个非常重要的寄存器
Dialogue: 0,0:46:33.56,0:46:39.32,English,,0,0,0,,And you don't want programs just to randomly change its value without them knowing what to do
Dialogue: 0,0:46:33.56,0:46:39.32,Chinese,,0,0,0,,并且你不希望程序在他们不知道该怎么做的情况下随机改变它的值
Dialogue: 0,0:46:39.82,0:46:43.62,English,,0,0,0,,But it turns out we'll also be careful with some of the other registers too
Dialogue: 0,0:46:39.82,0:46:43.62,Chinese,,0,0,0,,但事实证明，我们对其他一些寄存器也要小心
Dialogue: 0,0:46:44.72,0:46:52.68,English,,0,0,0,,And so here's sort of a thought experiment imagine we had a function called "yoo" that's going to call "who"
Dialogue: 0,0:46:44.72,0:46:52.68,Chinese,,0,0,0,,所以这是一种思想实验，想象我们有一个函数叫做“yoo”，它将调用“who”
Dialogue: 0,0:46:53.68,0:47:01.56,English,,0,0,0,,And it has some data that it wants to put somewhere
Dialogue: 0,0:46:53.68,0:47:01.56,Chinese,,0,0,0,,它有一些想要存储的数据
Dialogue: 0,0:47:02.70,0:47:06.44,English,,0,0,0,,And then when...who's going to get called
Dialogue: 0,0:47:02.70,0:47:06.44,Chinese,,0,0,0,,当"who"被调用的时候
Dialogue: 0,0:47:06.92,0:47:15.20,English,,0,0,0,,And then the question is can I rely on the fact that register %rdx will still hold the number 15213
Dialogue: 0,0:47:06.92,0:47:15.20,Chinese,,0,0,0,,然后问题是我可以依赖寄存器％rdx仍然保持数字15213的事实吗
Dialogue: 0,0:47:16.02,0:47:17.96,English,,0,0,0,,And the answer is not in general
Dialogue: 0,0:47:16.02,0:47:17.96,Chinese,,0,0,0,,答案一般是否定的
Dialogue: 0,0:47:18.16,0:47:23.08,English,,0,0,0,,Because “who” might have overwritten %rdx and put something else there
Dialogue: 0,0:47:18.16,0:47:23.08,Chinese,,0,0,0,,因为"who"可能覆盖了％rdx并在那里放了其他东西
Dialogue: 0,0:47:25.46,0:47:30.58,English,,0,0,0,,So in particular if "who" did some operation involving register %rdx
Dialogue: 0,0:47:25.46,0:47:30.58,Chinese,,0,0,0,,所以特别是如果"who"做了一些涉及寄存器％rdx的操作
Dialogue: 0,0:47:31.20,0:47:33.74,English,,0,0,0,,It could have messed up the value that was there before
Dialogue: 0,0:47:31.20,0:47:33.74,Chinese,,0,0,0,,它可能弄乱了之前的值
Dialogue: 0,0:47:36.42,0:47:42.38,English,,0,0,0,,So the obvious answer is while you should not have used %rdx for that purpose right
Dialogue: 0,0:47:36.42,0:47:42.38,Chinese,,0,0,0,,所以显而易见的答案是你不应该为此目的使用％rdx
Dialogue: 0,0:47:43.38,0:47:48.22,English,,0,0,0,,And that's why we will come up with a set of conventions
Dialogue: 0,0:47:43.38,0:47:48.22,Chinese,,0,0,0,,这就是为什么我们会提出一系列惯例
Dialogue: 0,0:47:49.12,0:47:51.72,English,,0,0,0,,So just some terminology
Dialogue: 0,0:47:49.12,0:47:51.72,Chinese,,0,0,0,,所以只是一些术语
Dialogue: 0,0:47:52.18,0:47:54.82,English,,0,0,0,,When we're talking about one function calling another
Dialogue: 0,0:47:52.18,0:47:54.82,Chinese,,0,0,0,,当我们谈论一个函数调用另一个函数时
Dialogue: 0,0:47:54.94,0:48:01.12,English,,0,0,0,,It's useful to have used the following words we'll call the calling function the caller
Dialogue: 0,0:47:54.94,0:48:01.12,Chinese,,0,0,0,,使用下面的单词是很有用的。我们称调用别的函数的函数为调用函数
Dialogue: 0,0:48:01.56,0:48:03.86,English,,0,0,0,,And the function that gets called the callee
Dialogue: 0,0:48:01.56,0:48:03.86,Chinese,,0,0,0,,并且被调用的称为被调用者的函数
Dialogue: 0,0:48:06.44,0:48:12.80,English,,0,0,0,,And now there's basically two ways we can manage register it can be what's called caller saved
Dialogue: 0,0:48:06.44,0:48:12.80,Chinese,,0,0,0,,现在基本上有两种方法可以管理寄存器，被称为调用者保存
Dialogue: 0,0:48:13.56,0:48:15.74,English,,0,0,0,,Which means if the caller really cares
Dialogue: 0,0:48:13.56,0:48:15.74,Chinese,,0,0,0,,这意味着如果调用者真正在意
Dialogue: 0,0:48:16.88,0:48:27.72,English,,0,0,0,,If you really want to value that will be there when it returns when control returns back to it
Dialogue: 0,0:48:16.88,0:48:27.72,Chinese,,0,0,0,,如果你真的想要这个值在返回时保持不变
Dialogue: 0,0:48:28.32,0:48:35.78,English,,0,0,0,,Then it should store it away first,it shouldn't assume that the register will be....
Dialogue: 0,0:48:28.32,0:48:35.78,Chinese,,0,0,0,,然后它应该首先存储它，它不应该假设寄存器将....
Dialogue: 0,0:48:36.76,0:48:39.68,English,,0,0,0,,It should assume that the register might get altered by it
Dialogue: 0,0:48:36.76,0:48:39.68,Chinese,,0,0,0,,它应该假设寄存器的值可能被改变
Dialogue: 0,0:48:42.18,0:48:46.96,English,,0,0,0,,But there's another class we can define it called callee save
Dialogue: 0,0:48:42.18,0:48:46.96,Chinese,,0,0,0,,但是我们可以定义另一个叫做被调用者保存的类
Dialogue: 0,0:48:47.52,0:48:52.34,English,,0,0,0,,Which is sort of a contract between all the functions and it's built into the ABI that says
Dialogue: 0,0:48:47.52,0:48:52.34,Chinese,,0,0,0,,这是所有函数之间的契约，它是内置于ABI中的
Dialogue: 0,0:48:53.06,0:48:56.92,English,,0,0,0,,If a particular function wants to alter the... alter this register
Dialogue: 0,0:48:53.06,0:48:56.92,Chinese,,0,0,0,,如果特定函数想要更改此寄存器
Dialogue: 0,0:48:57.48,0:49:02.02,English,,0,0,0,,What it needs to do is first store it away and it will do it by putting the value in the stack
Dialogue: 0,0:48:57.48,0:49:02.02,Chinese,,0,0,0,,它需要做的是先将它存储起来，然后将值放入堆栈中
Dialogue: 0,0:49:02.52,0:49:06.04,English,,0,0,0,,And then before we return from that procedure
Dialogue: 0,0:49:02.52,0:49:06.04,Chinese,,0,0,0,,然后在我们从该过程返回之前
Dialogue: 0,0:49:06.28,0:49:09.18,English,,0,0,0,,We should restore it back to whatever it was before
Dialogue: 0,0:49:06.28,0:49:09.18,Chinese,,0,0,0,,我们应该把它恢复到以前的状态
Dialogue: 0,0:49:09.78,0:49:12.38,English,,0,0,0,,So that's a convention called callee save
Dialogue: 0,0:49:09.78,0:49:12.38,Chinese,,0,0,0,,所以这是一个名为被调用者保存的约定
Dialogue: 0,0:49:13.02,0:49:16.84,English,,0,0,0,,And it's a little less intuitive and it takes a while to get the hang of this
Dialogue: 0,0:49:13.02,0:49:16.84,Chinese,,0,0,0,,它有点不那么直观，需要一段时间才能掌握这一点
Dialogue: 0,0:49:16.86,0:49:18.90,English,,0,0,0,,But you'll begin to see its value
Dialogue: 0,0:49:16.86,0:49:18.90,Chinese,,0,0,0,,但你会开始看到它的价值
Dialogue: 0,0:49:21.70,0:49:23.86,English,,0,0,0,,So in particular with this ABI
Dialogue: 0,0:49:21.70,0:49:23.86,Chinese,,0,0,0,,所以特别是这个ABI
Dialogue: 0,0:49:25.28,0:49:31.06,English,,0,0,0,,We've already seen %rax used for the return value
Dialogue: 0,0:49:25.28,0:49:31.06,Chinese,,0,0,0,,我们已经看到％rax用于返回值
Dialogue: 0,0:49:31.46,0:49:36.98,English,,0,0,0,,And we've seen these six registers that get used for passing arguments
Dialogue: 0,0:49:31.46,0:49:36.98,Chinese,,0,0,0,,我们已经看到这六个寄存器用于传递参数
Dialogue: 0,0:49:38.06,0:49:49.01,English,,0,0,0,,And will also designate registers %r10 and %r11 to be just temporary values that can be altered by any function
Dialogue: 0,0:49:38.06,0:49:49.01,Chinese,,0,0,0,,寄存器%r10与%r11用于存储可以被任何函数修改的临时值
Dialogue: 0,0:49:49.18,0:49:50.80,English,,0,0,0,,That's meaning of caller saved
Dialogue: 0,0:49:49.18,0:49:50.80,Chinese,,0,0,0,,这是调用者保存的意思
Dialogue: 0,0:49:51.26,0:49:56.96,English,,0,0,0,,We've already seen actually within code often them overriding these registers
Dialogue: 0,0:49:51.26,0:49:56.96,Chinese,,0,0,0,,我们已经在代码中看到它们通常会覆盖这些寄存器
Dialogue: 0,0:49:56.96,0:49:59.70,English,,0,0,0,,Because whatever gets passed to a function
Dialogue: 0,0:49:56.96,0:49:59.70,Chinese,,0,0,0,,因为无论什么传递给函数
Dialogue: 0,0:50:00.68,0:50:03.38,English,,0,0,0,,The function can do whatever it wants to that data
Dialogue: 0,0:50:00.68,0:50:03.38,Chinese,,0,0,0,,该函数可以对数据执行任何操作
Dialogue: 0,0:50:04.48,0:50:07.28,English,,0,0,0,,As long as it's not somehow corrupting other data
Dialogue: 0,0:50:04.48,0:50:07.28,Chinese,,0,0,0,,只要它不会以某种方式破坏其他数据
Dialogue: 0,0:50:07.28,0:50:10.84,English,,0,0,0,,So those often get used as temporary storage as well
Dialogue: 0,0:50:07.28,0:50:10.84,Chinese,,0,0,0,,所以这些通常也被用作临时存储
Dialogue: 0,0:50:12.92,0:50:19.00,English,,0,0,0,,And %rax gets often overwritten multiple times before it gets set to a final return value
Dialogue: 0,0:50:12.92,0:50:19.00,Chinese,,0,0,0,,并且％rax在被设置为最终返回值之前经常被多次覆盖
Dialogue: 0,0:50:21.08,0:50:25.68,English,,0,0,0,,But we're going to say that these four registers and most commonly %rbx
Dialogue: 0,0:50:21.08,0:50:25.68,Chinese,,0,0,0,,但我们要说的是这四个寄存器，最常见的是％rbx
Dialogue: 0,0:50:28.14,0:50:30.20,English,,0,0,0,,Are our what are called callee-saved registers
Dialogue: 0,0:50:28.14,0:50:30.20,Chinese,,0,0,0,,我们称之为被调用者保存的寄存器
Dialogue: 0,0:50:30.20,0:50:34.74,English,,0,0,0,,Meaning they'll only get used in this special way that if a function wants to alter it
Dialogue: 0,0:50:30.20,0:50:34.74,Chinese,,0,0,0,,意味着它们只会以这种特殊方式使用，如果一个函数想要改变它
Dialogue: 0,0:50:35.10,0:50:40.02,English,,0,0,0,,One of these registers has to push...it will push the value on the stack
Dialogue: 0,0:50:35.10,0:50:40.02,Chinese,,0,0,0,,其中一个寄存器必须把值push到栈中
Dialogue: 0,0:50:40.52,0:50:44.02,English,,0,0,0,,And then just before returning it will pop that value back off the stack
Dialogue: 0,0:50:40.52,0:50:44.02,Chinese,,0,0,0,,然后在返回之前它会将该值从栈中pop出
Dialogue: 0,0:50:44.92,0:50:50.94,English,,0,0,0,,So register %rbp as I told you about is special, if you're using frame pointers
Dialogue: 0,0:50:44.92,0:50:50.94,Chinese,,0,0,0,,所以注册％rbp正如我告诉你的那样特别，如果你正在使用帧指针
Dialogue: 0,0:50:51.36,0:50:58.06,English,,0,0,0,,If you're not using frame pointers then it can be treated as a callee-saved register
Dialogue: 0,0:50:51.36,0:50:58.06,Chinese,,0,0,0,,如果你不使用帧指针，则可以将其视为被调用者保存的寄存器
Dialogue: 0,0:50:58.06,0:50:59.98,English,,0,0,0,,So I'll get back to that in a minute
Dialogue: 0,0:50:58.06,0:50:59.98,Chinese,,0,0,0,,所以我会在一分钟后再回过头来看看
Dialogue: 0,0:50:59.98,0:51:05.84,English,,0,0,0,,The fact you can combine those two and it works fine is actually a little bit subtle
Dialogue: 0,0:50:59.98,0:51:05.84,Chinese,,0,0,0,,你可以将这两者结合起来并且工作正常的事实实际上有点微妙
Dialogue: 0,0:51:06.38,0:51:11.44,English,,0,0,0,,And then as I mentioned %rsp is special you don't mess with that unless you know what you're doing
Dialogue: 0,0:51:06.38,0:51:11.44,Chinese,,0,0,0,,然后正如我所提到的，％rsp是特别的，除非你知道你在做什么，否则你不要乱用它
Dialogue: 0,0:51:12.86,0:51:20.30,English,,0,0,0,,So let's look at an example of this use of callee-save registers and why how it works
Dialogue: 0,0:51:12.86,0:51:20.30,Chinese,,0,0,0,,那么让我们看一下被调用者保存寄存器的使用示例及其工作原理
Dialogue: 0,0:51:20.84,0:51:28.56,English,,0,0,0,,And I'll do it by a version of this similar function to what we did before
Dialogue: 0,0:51:20.84,0:51:28.56,Chinese,,0,0,0,,我会通过一个类似于这个函数的例子来解释
Dialogue: 0,0:51:32.24,0:51:45.28,English,,0,0,0,,But now what I'm going to do is my return value Is to add x which is an argument of being passed to this function
Dialogue: 0,0:51:32.24,0:51:45.28,Chinese,,0,0,0,,但现在我要做的就是，返回值需要加上x，它是传递给此函数的参数
Dialogue: 0,0:51:45.28,0:51:47.30,English,,0,0,0,,There were no arguments in the earlier version
Dialogue: 0,0:51:45.28,0:51:47.30,Chinese,,0,0,0,,早期版本中没有任何参数
Dialogue: 0,0:51:47.96,0:51:54.60,English,,0,0,0,,So somehow I have to have x, it gets passed originally in register %rdi as you know
Dialogue: 0,0:51:47.96,0:51:54.60,Chinese,,0,0,0,,所以我必须有x，它最初在寄存器％rdi中传递，如你所知
Dialogue: 0,0:51:56.56,0:51:58.62,English,,0,0,0,,But %rdi might...
Dialogue: 0,0:51:56.56,0:51:58.62,Chinese,,0,0,0,,但％rdi可能......
Dialogue: 0,0:51:59.06,0:52:03.34,English,,0,0,0,,Well I'm going to have to reuse register %rdi to pass value to "incr"
Dialogue: 0,0:51:59.06,0:52:03.34,Chinese,,0,0,0,,好吧，我将不得不重用register％rdi将值传递给“incr”
Dialogue: 0,0:52:03.82,0:52:05.90,English,,0,0,0,,So somehow I have to do something with x
Dialogue: 0,0:52:03.82,0:52:05.90,Chinese,,0,0,0,,所以我不得不用x做点什么
Dialogue: 0,0:52:06.42,0:52:11.12,English,,0,0,0,,Because I'm going to need x, when I return back to here after the call
Dialogue: 0,0:52:06.42,0:52:11.12,Chinese,,0,0,0,,因为当我从调用中返回后需要x
Dialogue: 0,0:52:11.76,0:52:15.62,English,,0,0,0,,So where am I going to put it well that's why I have callee-saved registers
Dialogue: 0,0:52:11.76,0:52:15.62,Chinese,,0,0,0,,所以我要把它放好，这就是为什么我有被调用者保存的寄存器
Dialogue: 0,0:52:16.68,0:52:18.82,English,,0,0,0,,And so you see that the code here
Dialogue: 0,0:52:16.68,0:52:18.82,Chinese,,0,0,0,,所以你在这里看到代码
Dialogue: 0,0:52:19.70,0:52:27.94,English,,0,0,0,,At the outset of this function then it will store away whatever is in %rbx currently it will put it on the stack
Dialogue: 0,0:52:19.70,0:52:27.94,Chinese,,0,0,0,,在此函数开始时，它将存储％rbx目前的值并将把它放在栈上
Dialogue: 0,0:52:28.70,0:52:33.98,English,,0,0,0,,And so now the the stack frame for this function looks like there's a return address
Dialogue: 0,0:52:28.70,0:52:33.98,Chinese,,0,0,0,,所以现在这个函数的栈帧看起来像是一个返回地址
Dialogue: 0,0:52:35.32,0:52:38.08,English,,0,0,0,,From before but I'm going to save the value of %rbx
Dialogue: 0,0:52:35.32,0:52:38.08,Chinese,,0,0,0,,从以前开始，我将保存％rbx的值
Dialogue: 0,0:52:38.74,0:52:43.02,English,,0,0,0,,And then I'm going to decrement the stack pointer by16 as I did before
Dialogue: 0,0:52:38.74,0:52:43.02,Chinese,,0,0,0,,然后我将按照之前的方式将栈指针递减16
Dialogue: 0,0:52:43.80,0:52:48.76,English,,0,0,0,,But that will be on top of the eight bytes I've already allocated to store %rbx
Dialogue: 0,0:52:43.80,0:52:48.76,Chinese,,0,0,0,,但这将是我已分配用于存储％rbx的八个字节之上
Dialogue: 0,0:52:51.84,0:52:54.44,English,,0,0,0,,And then you'll see within the code
Dialogue: 0,0:52:51.84,0:52:54.44,Chinese,,0,0,0,,然后你会在代码中看到
Dialogue: 0,0:52:55.46,0:52:58.90,English,,0,0,0,,For example when it wants to compute this return value
Dialogue: 0,0:52:55.46,0:52:58.90,Chinese,,0,0,0,,例如，当它想要计算此返回值时
Dialogue: 0,0:52:59.38,0:53:07.40,English,,0,0,0,,It can assume that %rbx when whatever this call does "incr"
Dialogue: 0,0:52:59.38,0:53:07.40,Chinese,,0,0,0,,我们可以假设无论incr这个调用做什么，%rbx...
Dialogue: 0,0:53:08.30,0:53:12.56,English,,0,0,0,,We assume "inrc" is well behaved that if it makes use of register %rbx
Dialogue: 0,0:53:08.30,0:53:12.56,Chinese,,0,0,0,,我们假设“inrc”表现良好，如果它使用寄存器％rbx
Dialogue: 0,0:53:12.78,0:53:14.78,English,,0,0,0,,It will fix it up before it returns
Dialogue: 0,0:53:12.78,0:53:14.78,Chinese,,0,0,0,,它会在它返回之前修复它
Dialogue: 0,0:53:15.44,0:53:22.58,English,,0,0,0,,And then this function well, in its exit code will not only increment the stack pointer
Dialogue: 0,0:53:15.44,0:53:22.58,Chinese,,0,0,0,,然后这个函数在它的退出指令中不仅会增加栈指针
Dialogue: 0,0:53:22.58,0:53:25.84,English,,0,0,0,,But it will then pop the value of %rbx back
Dialogue: 0,0:53:22.58,0:53:25.84,Chinese,,0,0,0,,但它会将％rbx的值重新弹回
Dialogue: 0,0:53:25.84,0:53:32.44,English,,0,0,0,,And so again you see this sort of bracketing push,pop,subtract,add
Dialogue: 0,0:53:25.84,0:53:32.44,Chinese,,0,0,0,,所以你再次看到这种push，pop，减去，添加
Dialogue: 0,0:53:32.44,0:53:33.74,English,,0,0,0,,And you'll notice that things
Dialogue: 0,0:53:32.44,0:53:33.74,Chinese,,0,0,0,,你会注意到这些事情
Dialogue: 0,0:53:34.52,0:53:39.10,English,,0,0,0,,On the clean-up part of it the end you sort of do things in the reverse order that they were done
Dialogue: 0,0:53:34.52,0:53:39.10,Chinese,,0,0,0,,在它的最终部分，你会按照与它们进来时相反的顺序做事
Dialogue: 0,0:53:39.32,0:53:42.58,English,,0,0,0,,Coming in again because of the stack discipline
Dialogue: 0,0:53:39.32,0:53:42.58,Chinese,,0,0,0,,这是由于堆栈规则
Dialogue: 0,0:53:44.06,0:53:48.66,English,,0,0,0,,So that's sort of a demonstration of this eight idea of an ABI that
Dialogue: 0,0:53:44.06,0:53:48.66,Chinese,,0,0,0,,所以这就是对这个ABI概念的一种证明
Dialogue: 0,0:53:49.28,0:53:53.60,English,,0,0,0,,Everyone will treat %rbx this way it will save it on the stack
Dialogue: 0,0:53:49.28,0:53:53.60,Chinese,,0,0,0,,每个人都会以这种方式处理％rbx，它会将它保存在堆栈中
Dialogue: 0,0:53:53.88,0:53:58.52,English,,0,0,0,,If it's going to alter it,if it's not going to alter it it doesn't have to save anything
Dialogue: 0,0:53:53.88,0:53:58.52,Chinese,,0,0,0,,如果它会改变它，如果它不会改变它，它不需要保存任何东西
Dialogue: 0,0:53:58.72,0:54:01.28,English,,0,0,0,,Whose question I saw?No
Dialogue: 0,0:53:58.72,0:54:01.28,Chinese,,0,0,0,,我看到了谁的问题？
Dialogue: 0,0:54:02.68,0:54:04.76,English,,0,0,0,,So we haven't seen that in other code
Dialogue: 0,0:54:02.68,0:54:04.76,Chinese,,0,0,0,,所以我们还没有在其他代码中看到过
Dialogue: 0,0:54:04.76,0:54:11.58,English,,0,0,0,,Because we didn't typically need it, that's again an example in this particular machine code
Dialogue: 0,0:54:04.76,0:54:11.58,Chinese,,0,0,0,,因为我们通常不需要它，所以这又是这个特定机器代码中的一个例子
Dialogue: 0,0:54:11.58,0:54:13.18,English,,0,0,0,,We only do what we have to do
Dialogue: 0,0:54:11.58,0:54:13.18,Chinese,,0,0,0,,我们只做我们必须做的事情
Dialogue: 0,0:54:16.38,0:54:16.94,English,,0,0,0,,Okay
Dialogue: 0,0:54:16.38,0:54:16.94,Chinese,,0,0,0,,好的
Dialogue: 0,0:54:19.84,0:54:22.58,English,,0,0,0,,Okay so now we can kind of put this all together
Dialogue: 0,0:54:19.84,0:54:22.58,Chinese,,0,0,0,,好的，现在我们可以把这些放在一起了
Dialogue: 0,0:54:23.26,0:54:29.04,English,,0,0,0,,And look at some examples of recursion and the important thing to keep in mind is
Dialogue: 0,0:54:23.26,0:54:29.04,Chinese,,0,0,0,,看一些递归的例子，要记住的重要事情是
Dialogue: 0,0:54:29.66,0:54:36.32,English,,0,0,0,,You know recursion is one of those sort of magical parts of computer science it seems like some black art
Dialogue: 0,0:54:29.66,0:54:36.32,Chinese,,0,0,0,,你知道递归是计算机科学中那些神奇的部分之一，它似乎是一些黑科技
Dialogue: 0,0:54:37.08,0:54:38.42,English,,0,0,0,,That it actually works
Dialogue: 0,0:54:37.08,0:54:38.42,Chinese,,0,0,0,,它确实有效
Dialogue: 0,0:54:39.90,0:54:43.54,English,,0,0,0,,But when you look at these low-level mechanisms it all works out
Dialogue: 0,0:54:39.90,0:54:43.54,Chinese,,0,0,0,,但是当你看到这些低级机制时，一切都会成功
Dialogue: 0,0:54:43.88,0:54:50.90,English,,0,0,0,,And the C compiler doesn't have to make any special consideration for
Dialogue: 0,0:54:43.88,0:54:50.90,Chinese,,0,0,0,,并且C编译器不必特别考虑
Dialogue: 0,0:54:51.54,0:54:54.34,English,,0,0,0,,A recursive function versus a normal function
Dialogue: 0,0:54:51.54,0:54:54.34,Chinese,,0,0,0,,递归函数与正常函数
Dialogue: 0,0:54:54.50,0:54:56.64,English,,0,0,0,,Because this whole stack discipline makes it work
Dialogue: 0,0:54:54.50,0:54:56.64,Chinese,,0,0,0,,因为整个堆栈规则使它工作
Dialogue: 0,0:54:59.64,0:55:07.14,English,,0,0,0,,So I'm going to illustrate that then with a version of this function I called "pcount_r" had various instance of it
Dialogue: 0,0:54:59.64,0:55:07.14,Chinese,,0,0,0,,所以我将说明，然后使用此函数的一个版本，我称之为“pcount_r”，它有各种各样的实例
Dialogue: 0,0:55:07.16,0:55:12.24,English,,0,0,0,,Where you remember it's the the role of this is to count the number of ones
Dialogue: 0,0:55:07.16,0:55:12.24,Chinese,,0,0,0,,你还记得它的作用是计算一个的数量
Dialogue: 0,0:55:12.80,0:55:14.54,English,,0,0,0,,In an initial word
Dialogue: 0,0:55:12.80,0:55:14.54,Chinese,,0,0,0,,用一句话来说
Dialogue: 0,0:55:15.04,0:55:17.10,English,,0,0,0,,So the recursive version of this says
Dialogue: 0,0:55:15.04,0:55:17.10,Chinese,,0,0,0,,所以这个的递归版本说
Dialogue: 0,0:55:17.66,0:55:21.00,English,,0,0,0,,If the argument is zero then it has no ones in it
Dialogue: 0,0:55:17.66,0:55:21.00,Chinese,,0,0,0,,如果参数为零，则其中没有参数
Dialogue: 0,0:55:21.64,0:55:29.32,English,,0,0,0,,Otherwise I take the leading bit... the least significant bit
Dialogue: 0,0:55:21.64,0:55:29.32,Chinese,,0,0,0,,否则我采取领先位...最不重要的位
Dialogue: 0,0:55:30.56,0:55:35.02,English,,0,0,0,,And I'll which is either going to be a one or a zero of course
Dialogue: 0,0:55:30.56,0:55:35.02,Chinese,,0,0,0,,而且我当然会成为一个或零
Dialogue: 0,0:55:35.60,0:55:40.76,English,,0,0,0,,And add that to what you get by shifting right x right by one position
Dialogue: 0,0:55:35.60,0:55:40.76,Chinese,,0,0,0,,并通过将右x向右移动一个位置来添加到你得到的东西
Dialogue: 0,0:55:41.14,0:55:43.86,English,,0,0,0,,And recursively counting the number of one bits in that
Dialogue: 0,0:55:41.14,0:55:43.86,Chinese,,0,0,0,,并递归计算其中一位的数量
Dialogue: 0,0:55:44.22,0:55:46.26,English,,0,0,0,,So pretty natural kind of recursion and
Dialogue: 0,0:55:44.22,0:55:46.26,Chinese,,0,0,0,,非常自然的递归和
Dialogue: 0,0:55:47.86,0:55:52.12,English,,0,0,0,,And keep in mind these are all unsigned numbers the argument is
Dialogue: 0,0:55:47.86,0:55:52.12,Chinese,,0,0,0,,请记住，这些参数都是unsigned类型
Dialogue: 0,0:55:52.54,0:55:55.52,English,,0,0,0,,So the right shifts are logical
Dialogue: 0,0:55:52.54,0:55:55.52,Chinese,,0,0,0,,所以右移都是逻辑右移
Dialogue: 0,0:55:56.24,0:56:01.26,English,,0,0,0,,This would really be a bad idea with arithmetic right
Dialogue: 0,0:55:56.24,0:56:01.26,Chinese,,0,0,0,,这对算术右移来说确实是一个坏主意
Dialogue: 0,0:56:02.66,0:56:04.32,English,,0,0,0,,And this is a code generated
Dialogue: 0,0:56:02.66,0:56:04.32,Chinese,,0,0,0,,这是一个生成的代码
Dialogue: 0,0:56:04.32,0:56:12.54,English,,0,0,0,,In general, recursive code it's going to always generate a bigger blob of code than the iterative version
Dialogue: 0,0:56:04.32,0:56:12.54,Chinese,,0,0,0,,通常，递归代码总是会产生比迭代版本更大的代码块
Dialogue: 0,0:56:12.84,0:56:14.84,English,,0,0,0,,Because it has to do all the stack stuff
Dialogue: 0,0:56:12.84,0:56:14.84,Chinese,,0,0,0,,因为它必须做所有堆栈的东西
Dialogue: 0,0:56:17.42,0:56:20.42,English,,0,0,0,,So this is about as simple as it gets in recursive calls
Dialogue: 0,0:56:17.42,0:56:20.42,Chinese,,0,0,0,,所以这和递归调用一样简单
Dialogue: 0,0:56:20.88,0:56:24.41,English,,0,0,0,,So let's just sort of pick it apart
Dialogue: 0,0:56:20.88,0:56:24.41,Chinese,,0,0,0,,所以，让我们把它分开吧
Dialogue: 0,0:56:24.92,0:56:28.94,English,,0,0,0,,Well if easy case is if x is zero you'll see what happens is
Dialogue: 0,0:56:24.92,0:56:28.94,Chinese,,0,0,0,,好吧，如果简单的情况是如果x为零你会看到发生了什么
Dialogue: 0,0:56:30.50,0:56:35.32,English,,0,0,0,,It first of all assumes x is going to be zero in fact
Dialogue: 0,0:56:30.50,0:56:35.32,Chinese,,0,0,0,,首先假设x实际上将为零
Dialogue: 0,0:56:35.76,0:56:40.98,English,,0,0,0,,And sets up the return value of zero to the register
Dialogue: 0,0:56:35.76,0:56:40.98,Chinese,,0,0,0,,并将寄存器的返回值设置为零
Dialogue: 0,0:56:41.56,0:56:45.52,English,,0,0,0,,And then it will test now while is x zero
Dialogue: 0,0:56:41.56,0:56:45.52,Chinese,,0,0,0,,然后它将在x为零时进行测试
Dialogue: 0,0:56:45.96,0:56:49.28,English,,0,0,0,,You remember the test instruction has two operands that get ended
Dialogue: 0,0:56:45.96,0:56:49.28,Chinese,,0,0,0,,你记得测试指令有两个结束的操作数
Dialogue: 0,0:56:49.28,0:56:54.02,English,,0,0,0,,So when they're... the same it just is testing the value of x here
Dialogue: 0,0:56:49.28,0:56:54.02,Chinese,,0,0,0,,所以，当它们......相同时，它只是在这里测试x的值
Dialogue: 0,0:56:54.92,0:57:00.52,English,,0,0,0,,And if that's equal je is means jump equal to 0 in this case
Dialogue: 0,0:56:54.92,0:57:00.52,Chinese,,0,0,0,,如果相同的je是指在这种情况下跳跃等于0
Dialogue: 0,0:57:01.10,0:57:03.86,English,,0,0,0,,Or might say jz is the same instruction
Dialogue: 0,0:57:01.10,0:57:03.86,Chinese,,0,0,0,,或者可能会说jz，它们是相同的指令
Dialogue: 0,0:57:04.36,0:57:11.62,English,,0,0,0,,So if the value equals zero, we'll jump to the end of the function and hit the return instruction
Dialogue: 0,0:57:04.36,0:57:11.62,Chinese,,0,0,0,,因此，如果值等于零，我们将跳转到函数的末尾并按下返回指令
Dialogue: 0,0:57:12.02,0:57:15.38,English,,0,0,0,,Like I said before the %rap; you can ignore that
Dialogue: 0,0:57:12.02,0:57:15.38,Chinese,,0,0,0,,就像我在％rap之前所说的那样;你可以忽略它
Dialogue: 0,0:57:17.02,0:57:18.16,English,,0,0,0,,So that handles that one
Dialogue: 0,0:57:17.02,0:57:18.16,Chinese,,0,0,0,,所以那个处理那一个
Dialogue: 0,0:57:19.68,0:57:23.00,English,,0,0,0,,And now the rest of the code is to handle this lower part
Dialogue: 0,0:57:19.68,0:57:23.00,Chinese,,0,0,0,,现在剩下的代码就是处理这个下半部分
Dialogue: 0,0:57:23.00,0:57:27.02,English,,0,0,0,,Where I have to set up the arguments to recursive call
Dialogue: 0,0:57:23.00,0:57:27.02,Chinese,,0,0,0,,我必须设置递归调用的参数
Dialogue: 0,0:57:27.02,0:57:35.38,English,,0,0,0,,I have to keep track of (what) at least the least significant bit of x is and handle all that stuff
Dialogue: 0,0:57:27.02,0:57:35.38,Chinese,,0,0,0,,我必须跟踪（什么）x最不重要的位并处理所有这些东西
Dialogue: 0,0:57:37.58,0:57:42.40,English,,0,0,0,,So here's the code and it doesn't need any other thing anything on the stack
Dialogue: 0,0:57:37.58,0:57:42.40,Chinese,,0,0,0,,所以这是代码，它不需要任何其他东西在堆栈上
Dialogue: 0,0:57:42.40,0:57:48.72,English,,0,0,0,,Other than a space to store %rbx which is whatever again
Dialogue: 0,0:57:42.40,0:57:48.72,Chinese,,0,0,0,,除了存储％rbx的空间之外，这又是什么
Dialogue: 0,0:57:48.98,0:57:51.22,English,,0,0,0,,Whatever was in %rbx when you enter
Dialogue: 0,0:57:48.98,0:57:51.22,Chinese,,0,0,0,,当你进入时，％rbx是什么
Dialogue: 0,0:57:51.66,0:57:55.24,English,,0,0,0,,I'm just going to put it on the stack I won't look at it I won't make use of it
Dialogue: 0,0:57:51.66,0:57:55.24,Chinese,,0,0,0,,我只是把它放在栈上我不会看它，我不会利用它
Dialogue: 0,0:57:55.98,0:58:02.18,English,,0,0,0,,But I'll have it there so I can restore the register when I return
Dialogue: 0,0:57:55.98,0:58:02.18,Chinese,,0,0,0,,但是我会把它放在那里，所以当我回来时我可以恢复寄存器
Dialogue: 0,0:58:02.82,0:58:05.36,English,,0,0,0,,So it will push the value under the stack
Dialogue: 0,0:58:02.82,0:58:05.36,Chinese,,0,0,0,,所以它会把值push到栈中
Dialogue: 0,0:58:07.32,0:58:16.92,English,,0,0,0,,And now the real meat of the the body of it is, it will copy x into %rbx
Dialogue: 0,0:58:07.32,0:58:16.92,Chinese,,0,0,0,,而现在它真正到主要部分是，它将x复制到％rbx
Dialogue: 0,0:58:17.02,0:58:20.74,English,,0,0,0,,Which we've just put on the stack so we can safely do it
Dialogue: 0,0:58:17.02,0:58:20.74,Chinese,,0,0,0,,我们刚刚把它放在栈上，这样我们就可以安全地完成它
Dialogue: 0,0:58:21.08,0:58:29.14,English,,0,0,0,,And we'll just set only will clear out at all but the least significant bit of that particular register
Dialogue: 0,0:58:21.08,0:58:29.14,Chinese,,0,0,0,,而且我们只会设置只清除该特定寄存器中最不重要的位
Dialogue: 0,0:58:29.52,0:58:36.92,English,,0,0,0,,And again this is one of these weird ones where I can use %ebx as a destination knowing that all 0 all the high order bits
Dialogue: 0,0:58:29.52,0:58:36.92,Chinese,,0,0,0,,再次，这是其中一个奇怪的，我可以使用％ebx作为目的地因为高位都是0
Dialogue: 0,0:58:38.16,0:58:43.40,English,,0,0,0,,And then I'm going to take x and I'm just going to shift it right by one position
Dialogue: 0,0:58:38.16,0:58:43.40,Chinese,,0,0,0,,然后我将采取x，我只是将它向右移动一个位置
Dialogue: 0,0:58:43.94,0:58:46.59,English,,0,0,0,,Which sets me up for this recursive call
Dialogue: 0,0:58:43.94,0:58:46.59,Chinese,,0,0,0,,这让我接受了这个递归调用
Dialogue: 0,0:58:47.04,0:58:51.04,English,,0,0,0,,So this red code does both of these parts of it here
Dialogue: 0,0:58:47.04,0:58:51.04,Chinese,,0,0,0,,所以这个红色代码在这里完成了这两部分
Dialogue: 0,0:58:52.48,0:58:56.14,English,,0,0,0,,And now I'm ready to call "pcount_r" recursively
Dialogue: 0,0:58:52.48,0:58:56.14,Chinese,,0,0,0,,而现在我已准备好递归调用“pcount_r”
Dialogue: 0,0:58:56.18,0:59:00.70,English,,0,0,0,,Because I have the shifted value in %rdi
Dialogue: 0,0:58:56.18,0:59:00.70,Chinese,,0,0,0,,因为我在％rdi中有移位的值
Dialogue: 0,0:59:03.92,0:59:09.30,English,,0,0,0,,And I know because this is a well behaved function
Dialogue: 0,0:59:03.92,0:59:09.30,Chinese,,0,0,0,,我知道因为这是一个表现良好的函数
Dialogue: 0,0:59:09.62,0:59:15.70,English,,0,0,0,,That when "pcount_r" returns it can assume that %rax holds  the recursive result
Dialogue: 0,0:59:09.62,0:59:15.70,Chinese,,0,0,0,,当“pcount_r”返回时，可以假设％rax保存递归结果
Dialogue: 0,0:59:16.98,0:59:22.28,English,,0,0,0,,And I also know even though "pcount_r" actually does modify %rbx
Dialogue: 0,0:59:16.98,0:59:22.28,Chinese,,0,0,0,,我也知道即使“pcount_r”确实修改了％rbx
Dialogue: 0,0:59:22.42,0:59:26.62,English,,0,0,0,,But I know because the code is well behaved
Dialogue: 0,0:59:22.42,0:59:26.62,Chinese,,0,0,0,,但我知道，因为代码很好
Dialogue: 0,0:59:27.08,0:59:31.24,English,,0,0,0,,The %rbx will get restored to whatever was there before
Dialogue: 0,0:59:27.08,0:59:31.24,Chinese,,0,0,0,,％rbx将恢复到之前的状态
Dialogue: 0,0:59:32.18,0:59:40.62,English,,0,0,0,,And %rbx in this case just before making the call I set it to the value of this we significant bit right
Dialogue: 0,0:59:32.18,0:59:40.62,Chinese,,0,0,0,,在这种情况下，％rbx就在调用之前我把它设置为这个右移后的值
Dialogue: 0,0:59:41.16,0:59:47.44,English,,0,0,0,,So when I return back I can assume that %rbx holds the least significant bit of x my original argument
Dialogue: 0,0:59:41.16,0:59:47.44,Chinese,,0,0,0,,因此当我返回时，我可以假设％rbx保持x原始参数的最低有效位
Dialogue: 0,0:59:47.82,0:59:50.68,English,,0,0,0,,And %rax call holds the recursive result
Dialogue: 0,0:59:47.82,0:59:50.68,Chinese,,0,0,0,,％rax调用保存递归结果
Dialogue: 0,0:59:51.18,0:59:53.78,English,,0,0,0,,So I can just add those two numbers together
Dialogue: 0,0:59:51.18,0:59:53.78,Chinese,,0,0,0,,所以我可以将这两个数字加在一起
Dialogue: 0,0:59:54.66,0:59:59.62,English,,0,0,0,,Call that the return value and I've correctly computed the result
Dialogue: 0,0:59:54.66,0:59:59.62,Chinese,,0,0,0,,调用返回值并且我已正确计算结果
Dialogue: 0,1:00:00.28,1:00:06.44,English,,0,0,0,,And then the final clean-up is to pop %rbx to restore whatever was in there
Dialogue: 0,1:00:00.28,1:00:06.44,Chinese,,0,0,0,,然后最后是弹出％rbx来恢复那里的东西
Dialogue: 0,1:00:06.90,1:00:08.46,English,,0,0,0,,And then to do the return
Dialogue: 0,1:00:06.90,1:00:08.46,Chinese,,0,0,0,,然后返回
Dialogue: 0,1:00:08.98,1:00:13.90,English,,0,0,0,,So again you see that the piece is all kind of it's a puzzle that all fits together
Dialogue: 0,1:00:08.98,1:00:13.90,Chinese,,0,0,0,,所以你再次看到这件作品是一种拼图，它们都融合在一起
Dialogue: 0,1:00:14.22,1:00:19.96,English,,0,0,0,,Because all the functions are using this common set of conventions about
Dialogue: 0,1:00:14.22,1:00:19.96,Chinese,,0,0,0,,因为所有函数都使用这个常见的约定
Dialogue: 0,1:00:20.48,1:00:21.92,English,,0,0,0,,Where arguments get past
Dialogue: 0,1:00:20.48,1:00:21.92,Chinese,,0,0,0,,参数在哪里传递
Dialogue: 0,1:00:22.54,1:00:25.48,English,,0,0,0,,What registers can be used...how registers
Dialogue: 0,1:00:22.54,1:00:25.48,Chinese,,0,0,0,,什么寄存器可以使用...如何寄存器
Dialogue: 0,1:00:26.50,1:00:32.42,English,,0,0,0,,If some registers have to be restored back if they get used and all that stuff works together
Dialogue: 0,1:00:26.50,1:00:32.42,Chinese,,0,0,0,,如果一些寄存器在被使用后必须被恢复，并且所有这些东西一起工作
Dialogue: 0,1:00:35.44,1:00:39.64,English,,0,0,0,,Which gets me back to just the point I was making before
Dialogue: 0,1:00:35.44,1:00:39.64,Chinese,,0,0,0,,这让我回到了之前的观点
Dialogue: 0,1:00:41.90,1:00:48.66,English,,0,0,0,,If you're using register %rbp for a frame pointer
Dialogue: 0,1:00:41.90,1:00:48.66,Chinese,,0,0,0,,如果你使用寄存器％rbp作为帧指针
Dialogue: 0,1:00:52.68,1:00:56.08,English,,0,0,0,,So typically point to the beginning of a frame like that
Dialogue: 0,1:00:52.68,1:00:56.08,Chinese,,0,0,0,,所以通常指向这样的帧的开头
Dialogue: 0,1:00:57.20,1:01:00.48,English,,0,0,0,,So imagine you have a function that needs a base pointer
Dialogue: 0,1:00:57.20,1:01:00.48,Chinese,,0,0,0,,所以假设你有一个需要基指针的函数
Dialogue: 0,1:01:00.48,1:01:08.46,English,,0,0,0,,Because as I mentioned the case is that if it has to within that function allocate some amount of space
Dialogue: 0,1:01:00.48,1:01:08.46,Chinese,,0,0,0,,因为正如我所提到的那样，如果它必须在该函数内分配一些空间
Dialogue: 0,1:01:08.46,1:01:10.66,English,,0,0,0,,It's unknown at compile time
Dialogue: 0,1:01:08.46,1:01:10.66,Chinese,,0,0,0,,它在编译时是未知的
Dialogue: 0,1:01:14.10,1:01:22.54,English,,0,0,0,,Well imagine now that some other code gets called deep recursive calls
Dialogue: 0,1:01:14.10,1:01:22.54,Chinese,,0,0,0,,现在想象一下其他一些代码被称为深度递归调用
Dialogue: 0,1:01:22.54,1:01:28.52,English,,0,0,0,,Or whatever that might do other things
Dialogue: 0,1:01:22.54,1:01:28.52,Chinese,,0,0,0,,或者其他可能做的事情
Dialogue: 0,1:01:28.90,1:01:33.06,English,,0,0,0,,Well if you treat %rbp as a callee saved register
Dialogue: 0,1:01:28.90,1:01:33.06,Chinese,,0,0,0,,好吧，如果你将％rbp视为被调用者保存的寄存器
Dialogue: 0,1:01:33.72,1:01:36.18,English,,0,0,0,,Then when these other functions return
Dialogue: 0,1:01:33.72,1:01:36.18,Chinese,,0,0,0,,然后当这些其他函数返回时
Dialogue: 0,1:01:36.64,1:01:40.82,English,,0,0,0,,If they've altered... if they made use of %rbp for one reason or another
Dialogue: 0,1:01:36.64,1:01:40.82,Chinese,,0,0,0,,如果他们改变了...如果他们出于某种原因使用了％rbp
Dialogue: 0,1:01:41.50,1:01:44.86,English,,0,0,0,,It's guaranteed that they will restore it back to
Dialogue: 0,1:01:41.50,1:01:44.86,Chinese,,0,0,0,,它保证会恢复它
Dialogue: 0,1:01:44.96,1:01:49.06,English,,0,0,0,,Whatever condition it was in originally before
Dialogue: 0,1:01:44.96,1:01:49.06,Chinese,,0,0,0,,无论以前是什么条件
Dialogue: 0,1:01:49.66,1:01:53.54,English,,0,0,0,,So now this function will have a reliable value of %rbp
Dialogue: 0,1:01:49.66,1:01:53.54,Chinese,,0,0,0,,所以现在这个函数将具有％rbp的可靠值
Dialogue: 0,1:01:54.27,1:01:59.04,English,,0,0,0,,So again it shows as long as all the code obeys these conventions on
Dialogue: 0,1:01:54.27,1:01:59.04,Chinese,,0,0,0,,所以只要所有代码遵守这些约定，它就会再次显示出来
Dialogue: 0,1:01:59.14,1:02:03.62,English,,0,0,0,,How it they use registers then sort of life is good
Dialogue: 0,1:01:59.14,1:02:03.62,Chinese,,0,0,0,,他们如何使用寄存器然后生活是好的
Dialogue: 0,1:02:03.62,1:02:08.12,English,,0,0,0,,You can make use of these...
Dialogue: 0,1:02:03.62,1:02:08.12,Chinese,,0,0,0,,你可以利用这些......
Dialogue: 0,1:02:08.18,1:02:12.78,English,,0,0,0,,So to have a trust that the things will be the way they are
Dialogue: 0,1:02:08.18,1:02:12.78,Chinese,,0,0,0,,所以要相信事情会是这样的
Dialogue: 0,1:02:13.44,1:02:19.22,English,,0,0,0,,And so again that's why there's this sort of very careful process for creating an ABI
Dialogue: 0,1:02:13.44,1:02:19.22,Chinese,,0,0,0,,这就是为什么创建ABI这种非常谨慎的过程的原因
Dialogue: 0,1:02:20.38,1:02:24.36,English,,0,0,0,,Of early on in the life time of a new processor
Dialogue: 0,1:02:20.38,1:02:24.36,Chinese,,0,0,0,,在新处理器的生命周期的早期
Dialogue: 0,1:02:24.78,1:02:28.34,English,,0,0,0,,So that all the compiler writers operating systems people
Dialogue: 0,1:02:24.78,1:02:28.34,Chinese,,0,0,0,,使所有编译器编写者操作系统的人
Dialogue: 0,1:02:29.16,1:02:33.74,English,,0,0,0,,And the ones who implement tools like gdb debugging tools
Dialogue: 0,1:02:29.16,1:02:33.74,Chinese,,0,0,0,,以及那些实现gdb调试工具等工具的人
Dialogue: 0,1:02:34.28,1:02:38.78,English,,0,0,0,,Kind of all I have the right set of standards by which they can work from
Dialogue: 0,1:02:34.28,1:02:38.78,Chinese,,0,0,0,,总之，我有他们可以使用的正确标准
Dialogue: 0,1:02:42.24,1:02:45.50,English,,0,0,0,,Okay so just to sort of wrap things up
Dialogue: 0,1:02:42.24,1:02:45.50,Chinese,,0,0,0,,好的，只是为了整理一下
Dialogue: 0,1:02:49.40,1:02:53.12,English,,0,0,0,,And I would say by the way this is the kind of thing you can
Dialogue: 0,1:02:49.40,1:02:53.12,Chinese,,0,0,0,,顺便说一句，这就是你能做到的事情
Dialogue: 0,1:02:56.52,1:03:00.38,English,,0,0,0,,I could lecture to you for weeks but to really get it in your mind
Dialogue: 0,1:02:56.52,1:03:00.38,Chinese,,0,0,0,,我可以在几周内给你讲课，但要真正理解
Dialogue: 0,1:03:00.68,1:03:06.22,English,,0,0,0,,The best way is to almost to hand execute some very simple examples
Dialogue: 0,1:03:00.68,1:03:06.22,Chinese,,0,0,0,,最好的方法是几乎手动执行一些非常简单的例子
Dialogue: 0,1:03:06.82,1:03:10.32,English,,0,0,0,,Or use a debugging tool and and run through them yourself
Dialogue: 0,1:03:06.82,1:03:10.32,Chinese,,0,0,0,,或者使用调试工具并自己运行它们
Dialogue: 0,1:03:10.90,1:03:14.32,English,,0,0,0,,Just to make sure you really are convinced that this is all going to work
Dialogue: 0,1:03:10.90,1:03:14.32,Chinese,,0,0,0,,只是为了确保你真的相信这一切都会起作用
Dialogue: 0,1:03:14.36,1:03:19.98,English,,0,0,0,,Because all these pieces just fit together and the way they fit together is what makes it work
Dialogue: 0,1:03:14.36,1:03:19.98,Chinese,,0,0,0,,因为所有这些部件恰好合在一起，它们相互配合的方式才能使它起作用
Dialogue: 0,1:03:20.92,1:03:25.24,English,,0,0,0,,So as I mentioned before and I'll say it again
Dialogue: 0,1:03:20.92,1:03:25.24,Chinese,,0,0,0,,正如我之前提到的，我会再说一遍
Dialogue: 0,1:03:25.86,1:03:30.80,English,,0,0,0,,That this this discipline is what makes recursion work
Dialogue: 0,1:03:25.86,1:03:30.80,Chinese,,0,0,0,,这个规则是使递归起作用的原因
Dialogue: 0,1:03:32.42,1:03:37.24,English,,0,0,0,,So the idea of having a stack frame for every call to a function means that
Dialogue: 0,1:03:32.42,1:03:37.24,Chinese,,0,0,0,,因此，每次调用函数时都有一个栈帧的想法意味着
Dialogue: 0,1:03:38.00,1:03:41.52,English,,0,0,0,,I can call a function call a function call a function call function
Dialogue: 0,1:03:38.00,1:03:41.52,Chinese,,0,0,0,,我可以调用函数调用函数调用函数调用函数
Dialogue: 0,1:03:42.58,1:03:49.58,English,,0,0,0,,When I'm deep in that recursion I still have data associated with the other outstanding calls to that function
Dialogue: 0,1:03:42.58,1:03:49.58,Chinese,,0,0,0,,当我深层递归时，我仍然拥有与该函数的其他未完成调用相关联的数据
Dialogue: 0,1:03:50.06,1:03:52.52,English,,0,0,0,,But each of them will have their own stack frames
Dialogue: 0,1:03:50.06,1:03:52.52,Chinese,,0,0,0,,但是每个函数都有自己的栈帧
Dialogue: 0,1:03:52.52,1:03:59.92,English,,0,0,0,,And so it has a place to store that sort of information that's associated with one particular instantiation of a function
Dialogue: 0,1:03:52.52,1:03:59.92,Chinese,,0,0,0,,所以它有一个地方，用于存储与函数的一个特定实例相关联的信息
Dialogue: 0,1:04:03.28,1:04:09.52,English,,0,0,0,,The register saving conventions we saw are a way that functions avoid sort of trashing each other's data
Dialogue: 0,1:04:03.28,1:04:09.52,Chinese,,0,0,0,,我们看到的寄存器保存约定是函数避免了相互摧毁彼此的数据的方式
Dialogue: 0,1:04:10.08,1:04:12.82,English,,0,0,0,,If I'm using a callee saved register
Dialogue: 0,1:04:10.08,1:04:12.82,Chinese,,0,0,0,,如果我正在使用被调用者保存的寄存器
Dialogue: 0,1:04:14.16,1:04:18.28,English,,0,0,0,,It's my obligation to save it and restore it properly
Dialogue: 0,1:04:14.16,1:04:18.28,Chinese,,0,0,0,,我有义务保存并正确恢复它
Dialogue: 0,1:04:18.68,1:04:25.20,English,,0,0,0,,It's the obligation of any function that gets called further down to also do that save and restore
Dialogue: 0,1:04:18.68,1:04:25.20,Chinese,,0,0,0,,任何被调用的函数都有义务进行保存和恢复
Dialogue: 0,1:04:26.80,1:04:38.46,English,,0,0,0,,And then this sort of... notion of a stack being the right match of how procedure call and return works
Dialogue: 0,1:04:26.80,1:04:38.46,Chinese,,0,0,0,,然后这种...... 堆栈的概念是过程调用和返回如何工作的正确匹配
Dialogue: 0,1:04:39.32,1:04:40.78,English,,0,0,0,,It if p calls q
Dialogue: 0,1:04:39.32,1:04:40.78,Chinese,,0,0,0,,如果p调用q
Dialogue: 0,1:04:41.44,1:04:43.10,English,,0,0,0,,Then before I go back to p
Dialogue: 0,1:04:41.44,1:04:43.10,Chinese,,0,0,0,,然后在我回到p之前
Dialogue: 0,1:04:43.26,1:04:47.40,English,,0,0,0,,q would have returned and so I won't need that storage for q anymore
Dialogue: 0,1:04:43.26,1:04:47.40,Chinese,,0,0,0,,q已经返回了，所以我不再需要q的存储空间了
Dialogue: 0,1:04:48.10,1:04:55.50,English,,0,0,0,,Those you've taken 150 or other places where you look at fancier languages
Dialogue: 0,1:04:48.10,1:04:55.50,Chinese,,0,0,0,,那些你已经在150或其他地方看到有趣的语言
Dialogue: 0,1:04:55.96,1:04:59.70,English,,0,0,0,,Don't have that status can trust that stack discipline
Dialogue: 0,1:04:55.96,1:04:59.70,Chinese,,0,0,0,,没有那种状态可以信任栈规则
Dialogue: 0,1:05:00.06,1:05:02.80,English,,0,0,0,,And they have to use some other mechanism though actually
Dialogue: 0,1:05:00.06,1:05:02.80,Chinese,,0,0,0,,实际上，他们必须使用其他一些机制
Dialogue: 0,1:05:03.58,1:05:06.92,English,,0,0,0,,If required use heap allocation of
Dialogue: 0,1:05:03.58,1:05:06.92,Chinese,,0,0,0,,如果需要使用堆分配
Dialogue: 0,1:05:07.38,1:05:10.08,English,,0,0,0,,Of the stack of the frames than all your stack frames
Dialogue: 0,1:05:07.38,1:05:10.08,Chinese,,0,0,0,,堆栈的帧数比所有堆栈帧
Dialogue: 0,1:05:10.30,1:05:14.08,English,,0,0,0,,To keep data around after a function returns
Dialogue: 0,1:05:10.30,1:05:14.08,Chinese,,0,0,0,,在函数返回后保持数据
Dialogue: 0,1:05:14.14,1:05:19.18,English,,0,0,0,,But for C and instead of all the standard commonplace languages
Dialogue: 0,1:05:14.14,1:05:19.18,Chinese,,0,0,0,,但是对于C而不是所有标准的普通语言
Dialogue: 0,1:05:19.66,1:05:22.04,English,,0,0,0,,The stack discipline is what is exactly what's needed
Dialogue: 0,1:05:19.66,1:05:22.04,Chinese,,0,0,0,,栈的规则正是所需要的
Dialogue: 0,1:05:22.40,1:05:25.74,English,,0,0,0,,And that's not next the designers of C knew this well
Dialogue: 0,1:05:22.40,1:05:25.74,Chinese,,0,0,0,,接下来，C的设计师非常了解这一点
Dialogue: 0,1:05:26.34,1:05:29.08,English,,0,0,0,,This matching of a stack to their language
Dialogue: 0,1:05:26.34,1:05:29.08,Chinese,,0,0,0,,栈与其语言的匹配
Dialogue: 0,1:05:30.68,1:05:35.04,English,,0,0,0,,And I'll mention also this we I was talking about simple recursion before
Dialogue: 0,1:05:30.68,1:05:35.04,Chinese,,0,0,0,,我还要提到这个，我之前谈的是简单的递归
Dialogue: 0,1:05:35.04,1:05:40.92,English,,0,0,0,,But there's also mutual recursion where a function say p calls q and then q might call p
Dialogue: 0,1:05:35.04,1:05:40.92,Chinese,,0,0,0,,但是也存在相互递归，其中函数说p调用q然后q可能调用p
Dialogue: 0,1:05:41.54,1:05:45.68,English,,0,0,0,,And it looks very exotic and  it's a quite clever
Dialogue: 0,1:05:41.54,1:05:45.68,Chinese,,0,0,0,,它看起来非常奇特，而且非常聪明
Dialogue: 0,1:05:46.06,1:05:49.38,English,,0,0,0,,But again how it's implemented is exactly what we've seen here
Dialogue: 0,1:05:46.06,1:05:49.38,Chinese,,0,0,0,,但是它的实现方式正是我们在这里看到的
Dialogue: 0,1:05:50.10,1:05:54.06,English,,0,0,0,,Doesn't take any special special kind of code
Dialogue: 0,1:05:50.10,1:05:54.06,Chinese,,0,0,0,,不需要任何特殊的特殊代码
Dialogue: 0,1:05:57.10,1:06:00.20,English,,0,0,0,,So
Dialogue: 0,1:05:57.10,1:06:00.20,Chinese,,0,0,0,,所以
Dialogue: 0,1:06:00.50,1:06:13.95,English,,0,0,0,,Then to finish up this is sort of what you need to remember about procedure calls that it's all about the stack discipline
Dialogue: 0,1:06:00.50,1:06:13.95,Chinese,,0,0,0,,作为结束，关于过程调用你需要记住的就是栈规则
Dialogue: 0,1:06:13.95,1:06:19.08,English,,0,0,0,,And you'll get as you're working through your lab
Dialogue: 0,1:06:13.95,1:06:19.08,Chinese,,0,0,0,,当你写lab的时候
Dialogue: 0,1:06:19.08,1:06:26.72,English,,0,0,0,,You'll just get much more ingrained to this idea of of the stack and what's on there and be able to examine
Dialogue: 0,1:06:19.08,1:06:26.72,Chinese,,0,0,0,,你会对栈的这个概念以及那里的内容有所了解，并且能够进行检查
Dialogue: 0,1:06:28.70,1:06:31.04,English,,0,0,0,,It okay so that's all I've got for today
Dialogue: 0,1:06:28.70,1:06:31.04,Chinese,,0,0,0,,这就是我今天要讲的
Dialogue: 0,1:06:31.04,1:06:35.45,English,,0,0,0,,So give you a little extra time in your calendar
Dialogue: 0,1:06:31.04,1:06:35.45,Chinese,,0,0,0,,所以在你的日历中给你一点额外的时间
